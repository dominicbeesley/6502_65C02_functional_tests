AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6117 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ;
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0000 =                  load_data_direct = 0
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0050 =                  zero_page = $50
                        
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = DATBASE
                        
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
c000 =                  code_segment = ROMBASE
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0000 =                  disable_decimal = 0
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0050 =                          org zero_page
                        ;break test interrupt save
0050 =                  irq_a   ds  1               ;a register
0051 =                  irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0052 =                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0052 =                  adfc    ds  1               ;carry flag before op
0053 =                  ad1     ds  1               ;operand 1 - accumulator
0054 =                  ad2     ds  1               ;operand 2 - memory / immediate
0055 =                  adrl    ds  1               ;expected result bits 0-7
0056 =                  adrh    ds  1               ;expected result bit 8 (carry)
0057 =                  adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0058 =                  sb2     ds  1               ;operand 2 complemented for subtract
0059 =                  zp_bss
0059 =                  zps     db  $80,1           ;additional shift pattern to test zero result & flag
005b =                  zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
005f =                  zp7f    db  $7f             ;test pattern for compare
                        ;logical zeropage operands
0060 =                  zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0064 =                  zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0068 =                  zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
006c =                  ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
006e =                          dw  abs1+1
0070 =                          dw  abs1+2
0072 =                          dw  abs1+3
0074 =                          dw  abs7f
0076 =                  inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0078 =                  indt    dw  abst            ;indirect pointer to store area in absolute memory
007a =                          dw  abst+1
007c =                          dw  abst+2
007e =                          dw  abst+3
0080 =                  inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0082 =                  indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0084 =                          dw  absAN+1
0086 =                          dw  absAN+2
0088 =                          dw  absAN+3
008a =                  indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
008c =                          dw  absEO+1
008e =                          dw  absEO+2
0090 =                          dw  absEO+3
0092 =                  indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0094 =                          dw  absOR+1
0096 =                          dw  absOR+2
0098 =                          dw  absOR+3
                        ;add/subtract indirect pointers
009a =                  adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
009c =                  sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
009e =                  adiy2   dw  ada2-$ff        ;with offset for indirect indexed
00a0 =                  sbiy2   dw  sba2-$ff
00a2 =                  zp_bss_end
                        
0200 =                          org data_segment
0200 =                  test_case   ds  1           ;current test number
0201 =                  ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 =                  abst                        ;6 bytes store/modify test area
0203 =                  ada2    ds  1               ;operand 2
0204 =                  sba2    ds  1               ;operand 2 complemented for subtract
0205 =                          ds  4               ;fill remaining bytes
0209 =                  data_bss
                            if load_data_direct = 1
                        ex_andi and #0              ;execute immediate opcodes
                                rts
                        ex_eori eor #0              ;execute immediate opcodes
                                rts
                        ex_orai ora #0              ;execute immediate opcodes
                                rts
                        ex_adci adc #0              ;execute immediate opcodes
                                rts
                        ex_sbci sbc #0              ;execute immediate opcodes
                                rts
                            else
0209 =                  ex_andi ds  3
020c =                  ex_eori ds  3
020f =                  ex_orai ds  3
0212 =                  ex_adci ds  3
0215 =                  ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 =                  abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c =                  abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d =                  fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 =                  rASL                                ;expected result ASL & ROL -carry
0221 =                  rROL    db  0,2,$86,$04,$82,0
0227 =                  rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d =                  rLSR                                ;expected result LSR & ROR -carry
022d =                  rROR    db  $40,0,$61,$41,$20,0
0233 =                  rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 =                  fASL                                ;expected flags for shifts
0239 =                  fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f =                  fROLc   db  fc,0,fnc,fc,fn,0        ;carry in
0245 =                  fLSR
0245 =                  fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b =                  fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 =                  rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 =                  fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b =                  absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f =                  absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 =                  absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 =                  absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b =                  absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f =                  absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 =                  absrlo  db  0,$ff,$7f,$80
0277 =                  absflo  db  fz,fn,0,fn
027b =                  data_bss_end
                        
                        
                                code
c000 =                          org code_segment
c000 : d8               start   cld
c001 : a2ff                     ldx #$ff
c003 : 9a                       txs
c004 : a900                     lda #0          ;*** test 0 = initialize
c006 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                        
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                        
                        ;pretest small branch offset
c009 : a205                     ldx #5
c00b : 4c33c0                   jmp psb_test
c00e :                  psb_bwok
c00e : a005                     ldy #5
c010 : d008                     bne psb_forw
                                trap        ;branch should be taken
c012 : 4c12c0          >        jmp *           ;failed anyway
                        
c015 : 88                       dey         ;forward landing zone
c016 : 88                       dey
c017 : 88                       dey
c018 : 88                       dey
c019 : 88                       dey
c01a :                  psb_forw
c01a : 88                       dey
c01b : 88                       dey
c01c : 88                       dey
c01d : 88                       dey
c01e : 88                       dey
c01f : f017                     beq psb_fwok
                                trap        ;forward offset
c021 : 4c21c0          >        jmp *           ;failed anyway
                        
                        
c024 : ca                       dex         ;backward landing zone
c025 : ca                       dex
c026 : ca                       dex
c027 : ca                       dex
c028 : ca                       dex
c029 :                  psb_back
c029 : ca                       dex
c02a : ca                       dex
c02b : ca                       dex
c02c : ca                       dex
c02d : ca                       dex
c02e : f0de                     beq psb_bwok
                                trap        ;backward offset
c030 : 4c30c0          >        jmp *           ;failed anyway
                        
c033 :                  psb_test
c033 : d0f4                     bne psb_back
                                trap        ;branch should be taken
c035 : 4c35c0          >        jmp *           ;failed anyway
                        
c038 :                  psb_fwok
                        
                        ;initialize BSS segment
                            if load_data_direct != 1
c038 : a248                     ldx #zp_end-zp_init-1
c03a : bd55f4           ld_zp   lda zp_init,x
c03d : 9559                     sta zp_bss,x
c03f : ca                       dex
c040 : 10f8                     bpl ld_zp
c042 : a271                     ldx #data_end-data_init-1
c044 : bd9ef4           ld_data lda data_init,x
c047 : 9d0902                   sta data_bss,x
c04a : ca                       dex
c04b : 10f7                     bpl ld_data
                              if ROM_vectors = 1
c04d : a205                     ldx #5
c04f : bd10f5           ld_vect lda vec_init,x
c052 : 9dfaff                   sta vec_bss,x
c055 : ca                       dex
c056 : 10f7                     bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                        
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test
c058 : ad0002          >            lda test_case   ;previous test
c05b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c05d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
c05f : a901            >            lda #test_num   ;*** next tests' number
c061 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
c064 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
c066 :                  range_loop
c066 : 88                       dey             ;next relative address
c067 : 98                       tya
c068 : aa                       tax             ;precharge count to end of loop
c069 : 1008                     bpl range_fw    ;calculate relative address
c06b : 18                       clc             ;avoid branch self or to relative address of branch
c06c : 6902                     adc #2
c06e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
c06f : ea                       nop
c070 : ea                       nop
c071 : ea                       nop
c072 : ea                       nop
c073 :                  range_fw
c073 : ea                       nop
c074 : ea                       nop
c075 : ea                       nop
c076 : ea                       nop
c077 : ea                       nop
c078 : 497f                     eor #$7f        ;complement except sign
c07a : 8d06c1                   sta range_adr   ;load into test target
c07d : a900                     lda #0          ;should set zero flag in status register
c07f : 4c05c1                   jmp range_op
                        
c082 : ca                       dex             ; offset landing zone - backward branch too far
c083 : ca                       dex
c084 : ca                       dex
c085 : ca                       dex
c086 : ca                       dex
                                ;relative address target field with branch under test in the middle
c087 : ca                       dex             ;-128 - max backward
c088 : ca                       dex
c089 : ca                       dex
c08a : ca                       dex
c08b : ca                       dex
c08c : ca                       dex
c08d : ca                       dex
c08e : ca                       dex
c08f : ca                       dex             ;-120
c090 : ca                       dex
c091 : ca                       dex
c092 : ca                       dex
c093 : ca                       dex
c094 : ca                       dex
c095 : ca                       dex
c096 : ca                       dex
c097 : ca                       dex
c098 : ca                       dex
c099 : ca                       dex             ;-110
c09a : ca                       dex
c09b : ca                       dex
c09c : ca                       dex
c09d : ca                       dex
c09e : ca                       dex
c09f : ca                       dex
c0a0 : ca                       dex
c0a1 : ca                       dex
c0a2 : ca                       dex
c0a3 : ca                       dex             ;-100
c0a4 : ca                       dex
c0a5 : ca                       dex
c0a6 : ca                       dex
c0a7 : ca                       dex
c0a8 : ca                       dex
c0a9 : ca                       dex
c0aa : ca                       dex
c0ab : ca                       dex
c0ac : ca                       dex
c0ad : ca                       dex             ;-90
c0ae : ca                       dex
c0af : ca                       dex
c0b0 : ca                       dex
c0b1 : ca                       dex
c0b2 : ca                       dex
c0b3 : ca                       dex
c0b4 : ca                       dex
c0b5 : ca                       dex
c0b6 : ca                       dex
c0b7 : ca                       dex             ;-80
c0b8 : ca                       dex
c0b9 : ca                       dex
c0ba : ca                       dex
c0bb : ca                       dex
c0bc : ca                       dex
c0bd : ca                       dex
c0be : ca                       dex
c0bf : ca                       dex
c0c0 : ca                       dex
c0c1 : ca                       dex             ;-70
c0c2 : ca                       dex
c0c3 : ca                       dex
c0c4 : ca                       dex
c0c5 : ca                       dex
c0c6 : ca                       dex
c0c7 : ca                       dex
c0c8 : ca                       dex
c0c9 : ca                       dex
c0ca : ca                       dex
c0cb : ca                       dex             ;-60
c0cc : ca                       dex
c0cd : ca                       dex
c0ce : ca                       dex
c0cf : ca                       dex
c0d0 : ca                       dex
c0d1 : ca                       dex
c0d2 : ca                       dex
c0d3 : ca                       dex
c0d4 : ca                       dex
c0d5 : ca                       dex             ;-50
c0d6 : ca                       dex
c0d7 : ca                       dex
c0d8 : ca                       dex
c0d9 : ca                       dex
c0da : ca                       dex
c0db : ca                       dex
c0dc : ca                       dex
c0dd : ca                       dex
c0de : ca                       dex
c0df : ca                       dex             ;-40
c0e0 : ca                       dex
c0e1 : ca                       dex
c0e2 : ca                       dex
c0e3 : ca                       dex
c0e4 : ca                       dex
c0e5 : ca                       dex
c0e6 : ca                       dex
c0e7 : ca                       dex
c0e8 : ca                       dex
c0e9 : ca                       dex             ;-30
c0ea : ca                       dex
c0eb : ca                       dex
c0ec : ca                       dex
c0ed : ca                       dex
c0ee : ca                       dex
c0ef : ca                       dex
c0f0 : ca                       dex
c0f1 : ca                       dex
c0f2 : ca                       dex
c0f3 : ca                       dex             ;-20
c0f4 : ca                       dex
c0f5 : ca                       dex
c0f6 : ca                       dex
c0f7 : ca                       dex
c0f8 : ca                       dex
c0f9 : ca                       dex
c0fa : ca                       dex
c0fb : ca                       dex
c0fc : ca                       dex
c0fd : ca                       dex             ;-10
c0fe : ca                       dex
c0ff : ca                       dex
c100 : ca                       dex
c101 : ca                       dex
c102 : ca                       dex
c103 : ca                       dex
c104 : ca                       dex             ;-3
c105 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
c106 =                  range_adr   = *+1       ;modifiable relative address
c105 : f03e                     beq *+64        ;+64 if called without modification
c107 : ca                       dex             ;+0
c108 : ca                       dex
c109 : ca                       dex
c10a : ca                       dex
c10b : ca                       dex
c10c : ca                       dex
c10d : ca                       dex
c10e : ca                       dex
c10f : ca                       dex
c110 : ca                       dex
c111 : ca                       dex             ;+10
c112 : ca                       dex
c113 : ca                       dex
c114 : ca                       dex
c115 : ca                       dex
c116 : ca                       dex
c117 : ca                       dex
c118 : ca                       dex
c119 : ca                       dex
c11a : ca                       dex
c11b : ca                       dex             ;+20
c11c : ca                       dex
c11d : ca                       dex
c11e : ca                       dex
c11f : ca                       dex
c120 : ca                       dex
c121 : ca                       dex
c122 : ca                       dex
c123 : ca                       dex
c124 : ca                       dex
c125 : ca                       dex             ;+30
c126 : ca                       dex
c127 : ca                       dex
c128 : ca                       dex
c129 : ca                       dex
c12a : ca                       dex
c12b : ca                       dex
c12c : ca                       dex
c12d : ca                       dex
c12e : ca                       dex
c12f : ca                       dex             ;+40
c130 : ca                       dex
c131 : ca                       dex
c132 : ca                       dex
c133 : ca                       dex
c134 : ca                       dex
c135 : ca                       dex
c136 : ca                       dex
c137 : ca                       dex
c138 : ca                       dex
c139 : ca                       dex             ;+50
c13a : ca                       dex
c13b : ca                       dex
c13c : ca                       dex
c13d : ca                       dex
c13e : ca                       dex
c13f : ca                       dex
c140 : ca                       dex
c141 : ca                       dex
c142 : ca                       dex
c143 : ca                       dex             ;+60
c144 : ca                       dex
c145 : ca                       dex
c146 : ca                       dex
c147 : ca                       dex
c148 : ca                       dex
c149 : ca                       dex
c14a : ca                       dex
c14b : ca                       dex
c14c : ca                       dex
c14d : ca                       dex             ;+70
c14e : ca                       dex
c14f : ca                       dex
c150 : ca                       dex
c151 : ca                       dex
c152 : ca                       dex
c153 : ca                       dex
c154 : ca                       dex
c155 : ca                       dex
c156 : ca                       dex
c157 : ca                       dex             ;+80
c158 : ca                       dex
c159 : ca                       dex
c15a : ca                       dex
c15b : ca                       dex
c15c : ca                       dex
c15d : ca                       dex
c15e : ca                       dex
c15f : ca                       dex
c160 : ca                       dex
c161 : ca                       dex             ;+90
c162 : ca                       dex
c163 : ca                       dex
c164 : ca                       dex
c165 : ca                       dex
c166 : ca                       dex
c167 : ca                       dex
c168 : ca                       dex
c169 : ca                       dex
c16a : ca                       dex
c16b : ca                       dex             ;+100
c16c : ca                       dex
c16d : ca                       dex
c16e : ca                       dex
c16f : ca                       dex
c170 : ca                       dex
c171 : ca                       dex
c172 : ca                       dex
c173 : ca                       dex
c174 : ca                       dex
c175 : ca                       dex             ;+110
c176 : ca                       dex
c177 : ca                       dex
c178 : ca                       dex
c179 : ca                       dex
c17a : ca                       dex
c17b : ca                       dex
c17c : ca                       dex
c17d : ca                       dex
c17e : ca                       dex
c17f : ca                       dex             ;+120
c180 : ca                       dex
c181 : ca                       dex
c182 : ca                       dex
c183 : ca                       dex
c184 : ca                       dex
c185 : ca                       dex
c186 : ea                       nop             ;offset landing zone - forward branch too far
c187 : ea                       nop
c188 : ea                       nop
c189 : ea                       nop
c18a : ea                       nop
c18b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
c18d : 4c8dc1          >        jmp *           ;failed anyway
                        
c190 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
c191 : ea                       nop
c192 : ea                       nop
c193 : ea                       nop
c194 : ea                       nop
c195 :                  range_ok
c195 : ea                       nop
c196 : ea                       nop
c197 : ea                       nop
c198 : ea                       nop
c199 : ea                       nop
c19a : c000                     cpy #0
c19c : f003                     beq range_end
c19e : 4c66c0                   jmp range_loop
c1a1 :                  range_end               ;range test successful
                            endif
                                next_test
c1a1 : ad0002          >            lda test_case   ;previous test
c1a4 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c1a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
c1a8 : a902            >            lda #test_num   ;*** next tests' number
c1aa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
c1ad : c001                     cpy #1          ;testing BNE true
c1af : d003                     bne test_bne
                                trap
c1b1 : 4cb1c1          >        jmp *           ;failed anyway
                        
c1b4 :                  test_bne
c1b4 : a900                     lda #0
c1b6 : c900                     cmp #0          ;test compare immediate
                                trap_ne
c1b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
c1ba : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
c1bc : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
c1be : c901                     cmp #1
                                trap_eq
c1c0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
c1c2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
c1c4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
c1c6 : aa                       tax
c1c7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
c1c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
c1cb : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
c1cd : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
c1cf : e001                     cpx #1
                                trap_eq
c1d1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
c1d3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
c1d5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
c1d7 : a8                       tay
c1d8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
c1da : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
c1dc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
c1de : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
c1e0 : c001                     cpy #1
                                trap_eq
c1e2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
c1e4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
c1e6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
c1e8 : ad0002          >            lda test_case   ;previous test
c1eb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c1ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
c1ef : a903            >            lda #test_num   ;*** next tests' number
c1f1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                        
c1f4 : a2ff                     ldx #$ff        ;initialize stack
c1f6 : 9a                       txs
c1f7 : a955                     lda #$55
c1f9 : 48                       pha
c1fa : a9aa                     lda #$aa
c1fc : 48                       pha
c1fd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
c200 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c202 : ba                       tsx
c203 : 8a                       txa             ;overwrite accu
c204 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
c206 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c208 : 68                       pla
c209 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
c20b : d0fe            >        bne *           ;failed not equal (non zero)
                        
c20d : 68                       pla
c20e : c955                     cmp #$55
                                trap_ne
c210 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c212 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
c215 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c217 : ba                       tsx
c218 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
c21a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c21c : ad0002          >            lda test_case   ;previous test
c21f : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c221 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
c223 : a904            >            lda #test_num   ;*** next tests' number
c225 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
c228 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
c22a : 48              >            pha         ;use stack to load status
c22b : 28              >            plp
                        
c22c : 101a                     bpl nbr1        ;branches should not be taken
c22e : 501b                     bvc nbr2
c230 : 901c                     bcc nbr3
c232 : d01d                     bne nbr4
c234 : 3003                     bmi br1         ;branches should be taken
                                trap
c236 : 4c36c2          >        jmp *           ;failed anyway
                        
c239 : 7003             br1     bvs br2
                                trap
c23b : 4c3bc2          >        jmp *           ;failed anyway
                        
c23e : b003             br2     bcs br3
                                trap
c240 : 4c40c2          >        jmp *           ;failed anyway
                        
c243 : f00f             br3     beq br4
                                trap
c245 : 4c45c2          >        jmp *           ;failed anyway
                        
c248 :                  nbr1
                                trap            ;previous bpl taken
c248 : 4c48c2          >        jmp *           ;failed anyway
                        
c24b :                  nbr2
                                trap            ;previous bvc taken
c24b : 4c4bc2          >        jmp *           ;failed anyway
                        
c24e :                  nbr3
                                trap            ;previous bcc taken
c24e : 4c4ec2          >        jmp *           ;failed anyway
                        
c251 :                  nbr4
                                trap            ;previous bne taken
c251 : 4c51c2          >        jmp *           ;failed anyway
                        
c254 : 08               br4     php
c255 : ba                       tsx
c256 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
c258 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c25a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
c25b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c25d : d0fe            >        bne *           ;failed not equal (non zero)
                        
c25f : ba                       tsx
c260 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
c262 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
c264 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
c266 : 48              >            pha         ;use stack to load status
c267 : 28              >            plp
                        
c268 : 301a                     bmi nbr11       ;branches should not be taken
c26a : 701b                     bvs nbr12
c26c : b01c                     bcs nbr13
c26e : f01d                     beq nbr14
c270 : 1003                     bpl br11        ;branches should be taken
                                trap
c272 : 4c72c2          >        jmp *           ;failed anyway
                        
c275 : 5003             br11    bvc br12
                                trap
c277 : 4c77c2          >        jmp *           ;failed anyway
                        
c27a : 9003             br12    bcc br13
                                trap
c27c : 4c7cc2          >        jmp *           ;failed anyway
                        
c27f : d00f             br13    bne br14
                                trap
c281 : 4c81c2          >        jmp *           ;failed anyway
                        
c284 :                  nbr11
                                trap            ;previous bmi taken
c284 : 4c84c2          >        jmp *           ;failed anyway
                        
c287 :                  nbr12
                                trap            ;previous bvs taken
c287 : 4c87c2          >        jmp *           ;failed anyway
                        
c28a :                  nbr13
                                trap            ;previous bcs taken
c28a : 4c8ac2          >        jmp *           ;failed anyway
                        
c28d :                  nbr14
                                trap            ;previous beq taken
c28d : 4c8dc2          >        jmp *           ;failed anyway
                        
c290 : 08               br14    php
c291 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
c292 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c294 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
c296 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
c298 : 48              >            pha         ;use stack to load status
c299 : 28              >            plp
                        
c29a : d002                     bne brzs1
c29c : f003                     beq brzs2
c29e :                  brzs1
                                trap            ;branch zero/non zero
c29e : 4c9ec2          >        jmp *           ;failed anyway
                        
c2a1 : b002             brzs2   bcs brzs3
c2a3 : 9003                     bcc brzs4
c2a5 :                  brzs3
                                trap            ;branch carry/no carry
c2a5 : 4ca5c2          >        jmp *           ;failed anyway
                        
c2a8 : 3002             brzs4   bmi brzs5
c2aa : 1003                     bpl brzs6
c2ac :                  brzs5
                                trap            ;branch minus/plus
c2ac : 4cacc2          >        jmp *           ;failed anyway
                        
c2af : 7002             brzs6   bvs brzs7
c2b1 : 5003                     bvc brzs8
c2b3 :                  brzs7
                                trap            ;branch overflow/no overflow
c2b3 : 4cb3c2          >        jmp *           ;failed anyway
                        
c2b6 :                  brzs8
                                set_stat carry
                       >            load_flag carry
c2b6 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
c2b8 : 48              >            pha         ;use stack to load status
c2b9 : 28              >            plp
                        
c2ba : f002                     beq brcs1
c2bc : d003                     bne brcs2
c2be :                  brcs1
                                trap            ;branch zero/non zero
c2be : 4cbec2          >        jmp *           ;failed anyway
                        
c2c1 : 9002             brcs2   bcc brcs3
c2c3 : b003                     bcs brcs4
c2c5 :                  brcs3
                                trap            ;branch carry/no carry
c2c5 : 4cc5c2          >        jmp *           ;failed anyway
                        
c2c8 : 3002             brcs4   bmi brcs5
c2ca : 1003                     bpl brcs6
c2cc :                  brcs5
                                trap            ;branch minus/plus
c2cc : 4cccc2          >        jmp *           ;failed anyway
                        
c2cf : 7002             brcs6   bvs brcs7
c2d1 : 5003                     bvc brcs8
c2d3 :                  brcs7
                                trap            ;branch overflow/no overflow
c2d3 : 4cd3c2          >        jmp *           ;failed anyway
                        
                        
c2d6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
c2d6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
c2d8 : 48              >            pha         ;use stack to load status
c2d9 : 28              >            plp
                        
c2da : f002                     beq brmi1
c2dc : d003                     bne brmi2
c2de :                  brmi1
                                trap            ;branch zero/non zero
c2de : 4cdec2          >        jmp *           ;failed anyway
                        
c2e1 : b002             brmi2   bcs brmi3
c2e3 : 9003                     bcc brmi4
c2e5 :                  brmi3
                                trap            ;branch carry/no carry
c2e5 : 4ce5c2          >        jmp *           ;failed anyway
                        
c2e8 : 1002             brmi4   bpl brmi5
c2ea : 3003                     bmi brmi6
c2ec :                  brmi5
                                trap            ;branch minus/plus
c2ec : 4cecc2          >        jmp *           ;failed anyway
                        
c2ef : 7002             brmi6   bvs brmi7
c2f1 : 5003                     bvc brmi8
c2f3 :                  brmi7
                                trap            ;branch overflow/no overflow
c2f3 : 4cf3c2          >        jmp *           ;failed anyway
                        
c2f6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
c2f6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
c2f8 : 48              >            pha         ;use stack to load status
c2f9 : 28              >            plp
                        
c2fa : f002                     beq brvs1
c2fc : d003                     bne brvs2
c2fe :                  brvs1
                                trap            ;branch zero/non zero
c2fe : 4cfec2          >        jmp *           ;failed anyway
                        
c301 : b002             brvs2   bcs brvs3
c303 : 9003                     bcc brvs4
c305 :                  brvs3
                                trap            ;branch carry/no carry
c305 : 4c05c3          >        jmp *           ;failed anyway
                        
c308 : 3002             brvs4   bmi brvs5
c30a : 1003                     bpl brvs6
c30c :                  brvs5
                                trap            ;branch minus/plus
c30c : 4c0cc3          >        jmp *           ;failed anyway
                        
c30f : 5002             brvs6   bvc brvs7
c311 : 7003                     bvs brvs8
c313 :                  brvs7
                                trap            ;branch overflow/no overflow
c313 : 4c13c3          >        jmp *           ;failed anyway
                        
c316 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
c316 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
c318 : 48              >            pha         ;use stack to load status
c319 : 28              >            plp
                        
c31a : f002                     beq brzc1
c31c : d003                     bne brzc2
c31e :                  brzc1
                                trap            ;branch zero/non zero
c31e : 4c1ec3          >        jmp *           ;failed anyway
                        
c321 : 9002             brzc2   bcc brzc3
c323 : b003                     bcs brzc4
c325 :                  brzc3
                                trap            ;branch carry/no carry
c325 : 4c25c3          >        jmp *           ;failed anyway
                        
c328 : 1002             brzc4   bpl brzc5
c32a : 3003                     bmi brzc6
c32c :                  brzc5
                                trap            ;branch minus/plus
c32c : 4c2cc3          >        jmp *           ;failed anyway
                        
c32f : 5002             brzc6   bvc brzc7
c331 : 7003                     bvs brzc8
c333 :                  brzc7
                                trap            ;branch overflow/no overflow
c333 : 4c33c3          >        jmp *           ;failed anyway
                        
c336 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
c336 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
c338 : 48              >            pha         ;use stack to load status
c339 : 28              >            plp
                        
c33a : d002                     bne brcc1
c33c : f003                     beq brcc2
c33e :                  brcc1
                                trap            ;branch zero/non zero
c33e : 4c3ec3          >        jmp *           ;failed anyway
                        
c341 : b002             brcc2   bcs brcc3
c343 : 9003                     bcc brcc4
c345 :                  brcc3
                                trap            ;branch carry/no carry
c345 : 4c45c3          >        jmp *           ;failed anyway
                        
c348 : 1002             brcc4   bpl brcc5
c34a : 3003                     bmi brcc6
c34c :                  brcc5
                                trap            ;branch minus/plus
c34c : 4c4cc3          >        jmp *           ;failed anyway
                        
c34f : 5002             brcc6   bvc brcc7
c351 : 7003                     bvs brcc8
c353 :                  brcc7
                                trap            ;branch overflow/no overflow
c353 : 4c53c3          >        jmp *           ;failed anyway
                        
c356 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
c356 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
c358 : 48              >            pha         ;use stack to load status
c359 : 28              >            plp
                        
c35a : d002                     bne brpl1
c35c : f003                     beq brpl2
c35e :                  brpl1
                                trap            ;branch zero/non zero
c35e : 4c5ec3          >        jmp *           ;failed anyway
                        
c361 : 9002             brpl2   bcc brpl3
c363 : b003                     bcs brpl4
c365 :                  brpl3
                                trap            ;branch carry/no carry
c365 : 4c65c3          >        jmp *           ;failed anyway
                        
c368 : 3002             brpl4   bmi brpl5
c36a : 1003                     bpl brpl6
c36c :                  brpl5
                                trap            ;branch minus/plus
c36c : 4c6cc3          >        jmp *           ;failed anyway
                        
c36f : 5002             brpl6   bvc brpl7
c371 : 7003                     bvs brpl8
c373 :                  brpl7
                                trap            ;branch overflow/no overflow
c373 : 4c73c3          >        jmp *           ;failed anyway
                        
c376 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
c376 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
c378 : 48              >            pha         ;use stack to load status
c379 : 28              >            plp
                        
c37a : d002                     bne brvc1
c37c : f003                     beq brvc2
c37e :                  brvc1
                                trap            ;branch zero/non zero
c37e : 4c7ec3          >        jmp *           ;failed anyway
                        
c381 : 9002             brvc2   bcc brvc3
c383 : b003                     bcs brvc4
c385 :                  brvc3
                                trap            ;branch carry/no carry
c385 : 4c85c3          >        jmp *           ;failed anyway
                        
c388 : 1002             brvc4   bpl brvc5
c38a : 3003                     bmi brvc6
c38c :                  brvc5
                                trap            ;branch minus/plus
c38c : 4c8cc3          >        jmp *           ;failed anyway
                        
c38f : 7002             brvc6   bvs brvc7
c391 : 5003                     bvc brvc8
c393 :                  brvc7
                                trap            ;branch overflow/no overflow
c393 : 4c93c3          >        jmp *           ;failed anyway
                        
c396 :                  brvc8
                                next_test
c396 : ad0002          >            lda test_case   ;previous test
c399 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c39b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
c39d : a905            >            lda #test_num   ;*** next tests' number
c39f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
c3a2 : a255                     ldx #$55        ;x & y protected
c3a4 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
c3a6 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
c3a8 : 48              >            pha         ;use stack to load status
c3a9 : a901            >            lda #1     ;precharge accu
c3ab : 28              >            plp
                        
c3ac : 48                       pha
                                tst_a 1,$ff
c3ad : 08              >            php         ;save flags
c3ae : c901            >            cmp #1     ;test result
                       >            trap_ne
c3b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3b2 : 68              >            pla         ;load status
c3b3 : 48              >            pha
                       >            cmp_flag $ff
c3b4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c3b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3b8 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
c3b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c3bb : 48              >            pha         ;use stack to load status
c3bc : a900            >            lda #0     ;precharge accu
c3be : 28              >            plp
                        
c3bf : 48                       pha
                                tst_a 0,0
c3c0 : 08              >            php         ;save flags
c3c1 : c900            >            cmp #0     ;test result
                       >            trap_ne
c3c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3c5 : 68              >            pla         ;load status
c3c6 : 48              >            pha
                       >            cmp_flag 0
c3c7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c3c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3cb : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
c3cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c3ce : 48              >            pha         ;use stack to load status
c3cf : a9ff            >            lda #$ff     ;precharge accu
c3d1 : 28              >            plp
                        
c3d2 : 48                       pha
                                tst_a $ff,$ff
c3d3 : 08              >            php         ;save flags
c3d4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c3d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3d8 : 68              >            pla         ;load status
c3d9 : 48              >            pha
                       >            cmp_flag $ff
c3da : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c3dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3de : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
c3df : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c3e1 : 48              >            pha         ;use stack to load status
c3e2 : a901            >            lda #1     ;precharge accu
c3e4 : 28              >            plp
                        
c3e5 : 48                       pha
                                tst_a 1,0
c3e6 : 08              >            php         ;save flags
c3e7 : c901            >            cmp #1     ;test result
                       >            trap_ne
c3e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3eb : 68              >            pla         ;load status
c3ec : 48              >            pha
                       >            cmp_flag 0
c3ed : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c3ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3f1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
c3f2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c3f4 : 48              >            pha         ;use stack to load status
c3f5 : a900            >            lda #0     ;precharge accu
c3f7 : 28              >            plp
                        
c3f8 : 48                       pha
                                tst_a 0,$ff
c3f9 : 08              >            php         ;save flags
c3fa : c900            >            cmp #0     ;test result
                       >            trap_ne
c3fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c3fe : 68              >            pla         ;load status
c3ff : 48              >            pha
                       >            cmp_flag $ff
c400 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c402 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c404 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
c405 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c407 : 48              >            pha         ;use stack to load status
c408 : a9ff            >            lda #$ff     ;precharge accu
c40a : 28              >            plp
                        
c40b : 48                       pha
                                tst_a $ff,0
c40c : 08              >            php         ;save flags
c40d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c40f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c411 : 68              >            pla         ;load status
c412 : 48              >            pha
                       >            cmp_flag 0
c413 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c415 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c417 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
c418 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
c41a : 48              >            pha         ;use stack to load status
c41b : a900            >            lda #0     ;precharge accu
c41d : 28              >            plp
                        
c41e : 68                       pla
                                tst_a $ff,$ff-zero
c41f : 08              >            php         ;save flags
c420 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c422 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c424 : 68              >            pla         ;load status
c425 : 48              >            pha
                       >            cmp_flag $ff-zero
c426 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c428 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c42a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
c42b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c42d : 48              >            pha         ;use stack to load status
c42e : a9ff            >            lda #$ff     ;precharge accu
c430 : 28              >            plp
                        
c431 : 68                       pla
                                tst_a 0,zero
c432 : 08              >            php         ;save flags
c433 : c900            >            cmp #0     ;test result
                       >            trap_ne
c435 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c437 : 68              >            pla         ;load status
c438 : 48              >            pha
                       >            cmp_flag zero
c439 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c43b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c43d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
c43e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c440 : 48              >            pha         ;use stack to load status
c441 : a9fe            >            lda #$fe     ;precharge accu
c443 : 28              >            plp
                        
c444 : 68                       pla
                                tst_a 1,$ff-zero-minus
c445 : 08              >            php         ;save flags
c446 : c901            >            cmp #1     ;test result
                       >            trap_ne
c448 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c44a : 68              >            pla         ;load status
c44b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
c44c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c44e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c450 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
c451 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c453 : 48              >            pha         ;use stack to load status
c454 : a900            >            lda #0     ;precharge accu
c456 : 28              >            plp
                        
c457 : 68                       pla
                                tst_a $ff,minus
c458 : 08              >            php         ;save flags
c459 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c45b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c45d : 68              >            pla         ;load status
c45e : 48              >            pha
                       >            cmp_flag minus
c45f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c461 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c463 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
c464 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c466 : 48              >            pha         ;use stack to load status
c467 : a9ff            >            lda #$ff     ;precharge accu
c469 : 28              >            plp
                        
c46a : 68                       pla
                                tst_a 0,$ff-minus
c46b : 08              >            php         ;save flags
c46c : c900            >            cmp #0     ;test result
                       >            trap_ne
c46e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c470 : 68              >            pla         ;load status
c471 : 48              >            pha
                       >            cmp_flag $ff-minus
c472 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c474 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c476 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
c477 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c479 : 48              >            pha         ;use stack to load status
c47a : a9fe            >            lda #$fe     ;precharge accu
c47c : 28              >            plp
                        
c47d : 68                       pla
                                tst_a 1,0
c47e : 08              >            php         ;save flags
c47f : c901            >            cmp #1     ;test result
                       >            trap_ne
c481 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c483 : 68              >            pla         ;load status
c484 : 48              >            pha
                       >            cmp_flag 0
c485 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c487 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c489 : 28              >            plp         ;restore status
                        
c48a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
c48c : d0fe            >        bne *           ;failed not equal (non zero)
                        
c48e : c0aa                     cpy #$aa
                                trap_ne
c490 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c492 : ad0002          >            lda test_case   ;previous test
c495 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c497 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
c499 : a906            >            lda #test_num   ;*** next tests' number
c49b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
c49e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c4a0 : 48              >            pha         ;use stack to load status
c4a1 : a93c            >            lda #$3c     ;precharge accu
c4a3 : 28              >            plp
                        
c4a4 : 49c3                     eor #$c3
                                tst_a $ff,fn
c4a6 : 08              >            php         ;save flags
c4a7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c4a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4ab : 68              >            pla         ;load status
c4ac : 48              >            pha
                       >            cmp_flag fn
c4ad : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c4af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4b1 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
c4b2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c4b4 : 48              >            pha         ;use stack to load status
c4b5 : a9c3            >            lda #$c3     ;precharge accu
c4b7 : 28              >            plp
                        
c4b8 : 49c3                     eor #$c3
                                tst_a 0,fz
c4ba : 08              >            php         ;save flags
c4bb : c900            >            cmp #0     ;test result
                       >            trap_ne
c4bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4bf : 68              >            pla         ;load status
c4c0 : 48              >            pha
                       >            cmp_flag fz
c4c1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c4c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4c5 : 28              >            plp         ;restore status
                        
                                next_test
c4c6 : ad0002          >            lda test_case   ;previous test
c4c9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c4cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
c4cd : a907            >            lda #test_num   ;*** next tests' number
c4cf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
c4d2 : a224                     ldx #$24
c4d4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
c4d6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c4d8 : 48              >            pha         ;use stack to load status
c4d9 : a918            >            lda #$18     ;precharge accu
c4db : 28              >            plp
                        
c4dc : ea                       nop
                                tst_a $18,0
c4dd : 08              >            php         ;save flags
c4de : c918            >            cmp #$18     ;test result
                       >            trap_ne
c4e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4e2 : 68              >            pla         ;load status
c4e3 : 48              >            pha
                       >            cmp_flag 0
c4e4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c4e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c4e8 : 28              >            plp         ;restore status
                        
c4e9 : e024                     cpx #$24
                                trap_ne
c4eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
c4ed : c042                     cpy #$42
                                trap_ne
c4ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
c4f1 : a2db                     ldx #$db
c4f3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
c4f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c4f7 : 48              >            pha         ;use stack to load status
c4f8 : a9e7            >            lda #$e7     ;precharge accu
c4fa : 28              >            plp
                        
c4fb : ea                       nop
                                tst_a $e7,$ff
c4fc : 08              >            php         ;save flags
c4fd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
c4ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c501 : 68              >            pla         ;load status
c502 : 48              >            pha
                       >            cmp_flag $ff
c503 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c505 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c507 : 28              >            plp         ;restore status
                        
c508 : e0db                     cpx #$db
                                trap_ne
c50a : d0fe            >        bne *           ;failed not equal (non zero)
                        
c50c : c0bd                     cpy #$bd
                                trap_ne
c50e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c510 : ad0002          >            lda test_case   ;previous test
c513 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c515 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
c517 : a908            >            lda #test_num   ;*** next tests' number
c519 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
c51c : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
c51e : 48              >            pha         ;use stack to load status
c51f : 28              >            plp
                        
c520 : a946                     lda #'F'
c522 : a241                     ldx #'A'
c524 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
c526 : 4c0ff3                   jmp test_far
c529 : ea                       nop
c52a : ea                       nop
                                trap_ne         ;runover protection
c52b : d0fe            >        bne *           ;failed not equal (non zero)
                        
c52d : e8                       inx
c52e : e8                       inx
c52f :                  far_ret
                                trap_eq         ;returned flags OK?
c52f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
c531 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
c533 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
c535 : 50fe            >        bvc *           ;failed overflow clear
                        
c537 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
c539 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c53b : e042                     cpx #('A'+1)
                                trap_ne
c53d : d0fe            >        bne *           ;failed not equal (non zero)
                        
c53f : c04f                     cpy #('R'-3)
                                trap_ne
c541 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c543 : ca                       dex
c544 : c8                       iny
c545 : c8                       iny
c546 : c8                       iny
c547 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
c549 : 4c52c5                   jmp test_near
c54c : ea                       nop
c54d : ea                       nop
                                trap_ne         ;runover protection
c54e : d0fe            >        bne *           ;failed not equal (non zero)
                        
c550 : e8                       inx
c551 : e8                       inx
c552 :                  test_near
                                trap_eq         ;passed flags OK?
c552 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
c554 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
c556 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
c558 : 50fe            >        bvc *           ;failed overflow clear
                        
c55a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
c55c : d0fe            >        bne *           ;failed not equal (non zero)
                        
c55e : e041                     cpx #'A'
                                trap_ne
c560 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c562 : c052                     cpy #'R'
                                trap_ne
c564 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c566 : ad0002          >            lda test_case   ;previous test
c569 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c56b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
c56d : a909            >            lda #test_num   ;*** next tests' number
c56f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
c572 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c574 : 48              >            pha         ;use stack to load status
c575 : 28              >            plp
                        
c576 : a949                     lda #'I'
c578 : a24e                     ldx #'N'
c57a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
c57c : 6c3ef3                   jmp (ptr_tst_ind)
c57f : ea                       nop
                                trap_ne         ;runover protection
c580 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c582 : 88                       dey
c583 : 88                       dey
c584 :                  ind_ret
c584 : 08                       php             ;either SP or Y count will fail, if we do not hit
c585 : 88                       dey
c586 : 88                       dey
c587 : 88                       dey
c588 : 28                       plp
                                trap_eq         ;returned flags OK?
c589 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
c58b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
c58d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
c58f : 50fe            >        bvc *           ;failed overflow clear
                        
c591 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
c593 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c595 : e04f                     cpx #('N'+1)
                                trap_ne
c597 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c599 : c03e                     cpy #('D'-6)
                                trap_ne
c59b : d0fe            >        bne *           ;failed not equal (non zero)
                        
c59d : ba                       tsx             ;SP check
c59e : e0ff                     cpx #$ff
                                trap_ne
c5a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c5a2 : ad0002          >            lda test_case   ;previous test
c5a5 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c5a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
c5a9 : a90a            >            lda #test_num   ;*** next tests' number
c5ab : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
c5ae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c5b0 : 48              >            pha         ;use stack to load status
c5b1 : 28              >            plp
                        
c5b2 : a94a                     lda #'J'
c5b4 : a253                     ldx #'S'
c5b6 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
c5b8 : 207df3                   jsr test_jsr
c5ba =                  jsr_ret = *-1           ;last address of jsr = return address
c5bb : 08                       php             ;either SP or Y count will fail, if we do not hit
c5bc : 88                       dey
c5bd : 88                       dey
c5be : 88                       dey
c5bf : 28                       plp
                                trap_eq         ;returned flags OK?
c5c0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
c5c2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
c5c4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
c5c6 : 50fe            >        bvc *           ;failed overflow clear
                        
c5c8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
c5ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
c5cc : e054                     cpx #('S'+1)
                                trap_ne
c5ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
c5d0 : c04c                     cpy #('R'-6)
                                trap_ne
c5d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c5d4 : ba                       tsx             ;sp?
c5d5 : e0ff                     cpx #$ff
                                trap_ne
c5d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c5d9 : ad0002          >            lda test_case   ;previous test
c5dc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c5de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
c5e0 : a90b            >            lda #test_num   ;*** next tests' number
c5e2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
c5e5 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
c5e7 : 48                       pha
c5e8 : a942                     lda #'B'
c5ea : a252                     ldx #'R'
c5ec : a04b                     ldy #'K'
c5ee : 28                       plp             ;N=0, V=0, Z=0, C=0
c5ef : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
c5f0 : 88                       dey             ;should not be executed
c5f1 :                  brk_ret0                ;address of break return
c5f1 : 08                       php             ;either SP or Y count will fail, if we do not hit
c5f2 : 88                       dey
c5f3 : 88                       dey
c5f4 : 88                       dey
c5f5 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
c5f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c5f9 : e053                     cpx #'R'+1
                                trap_ne
c5fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
c5fd : c045                     cpy #'K'-6
                                trap_ne
c5ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
c601 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
c602 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c604 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c606 : ba                       tsx             ;sp?
c607 : e0ff                     cpx #$ff
                                trap_ne
c609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
c60b : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
c60d : 48                       pha
c60e : a9bd                     lda #$ff-'B'
c610 : a2ad                     ldx #$ff-'R'
c612 : a0b4                     ldy #$ff-'K'
c614 : 28                       plp             ;N=1, V=1, Z=1, C=1
c615 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
c616 : 88                       dey             ;should not be executed
c617 :                  brk_ret1                ;address of break return
c617 : 08                       php             ;either SP or Y count will fail, if we do not hit
c618 : 88                       dey
c619 : 88                       dey
c61a : 88                       dey
c61b : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
c61d : d0fe            >        bne *           ;failed not equal (non zero)
                        
c61f : e0ae                     cpx #$ff-'R'+1
                                trap_ne
c621 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c623 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
c625 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c627 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
c628 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c62a : d0fe            >        bne *           ;failed not equal (non zero)
                        
c62c : ba                       tsx             ;sp?
c62d : e0ff                     cpx #$ff
                                trap_ne
c62f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
c631 : ad0002          >            lda test_case   ;previous test
c634 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c636 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
c638 : a90c            >            lda #test_num   ;*** next tests' number
c63a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
c63d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c63f : 48              >            pha         ;use stack to load status
c640 : 28              >            plp
                        
c641 : 18                       clc
                                tst_stat $ff-carry
c642 : 08              >            php         ;save status
c643 : 68              >            pla         ;use stack to retrieve status
c644 : 48              >            pha
                       >            cmp_flag $ff-carry
c645 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c647 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c649 : 28              >            plp         ;restore status
                        
c64a : 38                       sec
                                tst_stat $ff
c64b : 08              >            php         ;save status
c64c : 68              >            pla         ;use stack to retrieve status
c64d : 48              >            pha
                       >            cmp_flag $ff
c64e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c650 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c652 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
c653 : 58                       cli
                                tst_stat $ff-intdis
c654 : 08              >            php         ;save status
c655 : 68              >            pla         ;use stack to retrieve status
c656 : 48              >            pha
                       >            cmp_flag $ff-intdis
c657 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c659 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c65b : 28              >            plp         ;restore status
                        
c65c : 78                       sei
                                tst_stat $ff
c65d : 08              >            php         ;save status
c65e : 68              >            pla         ;use stack to retrieve status
c65f : 48              >            pha
                       >            cmp_flag $ff
c660 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c662 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c664 : 28              >            plp         ;restore status
                        
                            endif
c665 : d8                       cld
                                tst_stat $ff-decmode
c666 : 08              >            php         ;save status
c667 : 68              >            pla         ;use stack to retrieve status
c668 : 48              >            pha
                       >            cmp_flag $ff-decmode
c669 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c66b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c66d : 28              >            plp         ;restore status
                        
c66e : f8                       sed
                                tst_stat $ff
c66f : 08              >            php         ;save status
c670 : 68              >            pla         ;use stack to retrieve status
c671 : 48              >            pha
                       >            cmp_flag $ff
c672 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c674 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c676 : 28              >            plp         ;restore status
                        
c677 : b8                       clv
                                tst_stat $ff-overfl
c678 : 08              >            php         ;save status
c679 : 68              >            pla         ;use stack to retrieve status
c67a : 48              >            pha
                       >            cmp_flag $ff-overfl
c67b : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c67d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c67f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
c680 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c682 : 48              >            pha         ;use stack to load status
c683 : 28              >            plp
                        
                                tst_stat 0
c684 : 08              >            php         ;save status
c685 : 68              >            pla         ;use stack to retrieve status
c686 : 48              >            pha
                       >            cmp_flag 0
c687 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c689 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c68b : 28              >            plp         ;restore status
                        
c68c : 38                       sec
                                tst_stat carry
c68d : 08              >            php         ;save status
c68e : 68              >            pla         ;use stack to retrieve status
c68f : 48              >            pha
                       >            cmp_flag carry
c690 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c692 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c694 : 28              >            plp         ;restore status
                        
c695 : 18                       clc
                                tst_stat 0
c696 : 08              >            php         ;save status
c697 : 68              >            pla         ;use stack to retrieve status
c698 : 48              >            pha
                       >            cmp_flag 0
c699 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c69b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c69d : 28              >            plp         ;restore status
                        
                            if I_flag = 3
c69e : 78                       sei
                                tst_stat intdis
c69f : 08              >            php         ;save status
c6a0 : 68              >            pla         ;use stack to retrieve status
c6a1 : 48              >            pha
                       >            cmp_flag intdis
c6a2 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6a6 : 28              >            plp         ;restore status
                        
c6a7 : 58                       cli
                                tst_stat 0
c6a8 : 08              >            php         ;save status
c6a9 : 68              >            pla         ;use stack to retrieve status
c6aa : 48              >            pha
                       >            cmp_flag 0
c6ab : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6af : 28              >            plp         ;restore status
                        
                            endif
c6b0 : f8                       sed
                                tst_stat decmode
c6b1 : 08              >            php         ;save status
c6b2 : 68              >            pla         ;use stack to retrieve status
c6b3 : 48              >            pha
                       >            cmp_flag decmode
c6b4 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6b8 : 28              >            plp         ;restore status
                        
c6b9 : d8                       cld
                                tst_stat 0
c6ba : 08              >            php         ;save status
c6bb : 68              >            pla         ;use stack to retrieve status
c6bc : 48              >            pha
                       >            cmp_flag 0
c6bd : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6c1 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
c6c2 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
c6c4 : 48              >            pha         ;use stack to load status
c6c5 : 28              >            plp
                        
                                tst_stat overfl
c6c6 : 08              >            php         ;save status
c6c7 : 68              >            pla         ;use stack to retrieve status
c6c8 : 48              >            pha
                       >            cmp_flag overfl
c6c9 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6cd : 28              >            plp         ;restore status
                        
c6ce : b8                       clv
                                tst_stat 0
c6cf : 08              >            php         ;save status
c6d0 : 68              >            pla         ;use stack to retrieve status
c6d1 : 48              >            pha
                       >            cmp_flag 0
c6d2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6d6 : 28              >            plp         ;restore status
                        
                                next_test
c6d7 : ad0002          >            lda test_case   ;previous test
c6da : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c6dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
c6de : a90d            >            lda #test_num   ;*** next tests' number
c6e0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA
c6e3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
c6e5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c6e7 : 48              >            pha         ;use stack to load status
c6e8 : 28              >            plp
                        
c6e9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
c6ea : 08              >            php         ;save flags
c6eb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c6ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6ef : 68              >            pla         ;load status
c6f0 : 48              >            pha
                       >            cmp_flag $ff-zero
c6f1 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c6f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6f5 : 28              >            plp         ;restore status
                        
c6f6 : e8                       inx             ;00
                                tst_x 0,$ff-minus
c6f7 : 08              >            php         ;save flags
c6f8 : e000            >            cpx #0     ;test result
                       >            trap_ne
c6fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c6fc : 68              >            pla         ;load status
c6fd : 48              >            pha
                       >            cmp_flag $ff-minus
c6fe : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c700 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c702 : 28              >            plp         ;restore status
                        
c703 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
c704 : 08              >            php         ;save flags
c705 : e001            >            cpx #1     ;test result
                       >            trap_ne
c707 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c709 : 68              >            pla         ;load status
c70a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c70b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c70d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c70f : 28              >            plp         ;restore status
                        
c710 : ca                       dex             ;00
                                tst_x 0,$ff-minus
c711 : 08              >            php         ;save flags
c712 : e000            >            cpx #0     ;test result
                       >            trap_ne
c714 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c716 : 68              >            pla         ;load status
c717 : 48              >            pha
                       >            cmp_flag $ff-minus
c718 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c71a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c71c : 28              >            plp         ;restore status
                        
c71d : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
c71e : 08              >            php         ;save flags
c71f : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c721 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c723 : 68              >            pla         ;load status
c724 : 48              >            pha
                       >            cmp_flag $ff-zero
c725 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c727 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c729 : 28              >            plp         ;restore status
                        
c72a : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
c72b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c72d : 48              >            pha         ;use stack to load status
c72e : 28              >            plp
                        
c72f : e8                       inx             ;ff
                                tst_x $ff,minus
c730 : 08              >            php         ;save flags
c731 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c733 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c735 : 68              >            pla         ;load status
c736 : 48              >            pha
                       >            cmp_flag minus
c737 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c739 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c73b : 28              >            plp         ;restore status
                        
c73c : e8                       inx             ;00
                                tst_x 0,zero
c73d : 08              >            php         ;save flags
c73e : e000            >            cpx #0     ;test result
                       >            trap_ne
c740 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c742 : 68              >            pla         ;load status
c743 : 48              >            pha
                       >            cmp_flag zero
c744 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c746 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c748 : 28              >            plp         ;restore status
                        
c749 : e8                       inx             ;01
                                tst_x 1,0
c74a : 08              >            php         ;save flags
c74b : e001            >            cpx #1     ;test result
                       >            trap_ne
c74d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c74f : 68              >            pla         ;load status
c750 : 48              >            pha
                       >            cmp_flag 0
c751 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c753 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c755 : 28              >            plp         ;restore status
                        
c756 : ca                       dex             ;00
                                tst_x 0,zero
c757 : 08              >            php         ;save flags
c758 : e000            >            cpx #0     ;test result
                       >            trap_ne
c75a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c75c : 68              >            pla         ;load status
c75d : 48              >            pha
                       >            cmp_flag zero
c75e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c760 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c762 : 28              >            plp         ;restore status
                        
c763 : ca                       dex             ;ff
                                tst_x $ff,minus
c764 : 08              >            php         ;save flags
c765 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c767 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c769 : 68              >            pla         ;load status
c76a : 48              >            pha
                       >            cmp_flag minus
c76b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c76d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c76f : 28              >            plp         ;restore status
                        
                        
c770 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
c772 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c774 : 48              >            pha         ;use stack to load status
c775 : 28              >            plp
                        
c776 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
c777 : 08              >            php         ;save flags
c778 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c77a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c77c : 68              >            pla         ;load status
c77d : 48              >            pha
                       >            cmp_flag $ff-zero
c77e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c780 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c782 : 28              >            plp         ;restore status
                        
c783 : c8                       iny             ;00
                                tst_y 0,$ff-minus
c784 : 08              >            php         ;save flags
c785 : c000            >            cpy #0     ;test result
                       >            trap_ne
c787 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c789 : 68              >            pla         ;load status
c78a : 48              >            pha
                       >            cmp_flag $ff-minus
c78b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c78d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c78f : 28              >            plp         ;restore status
                        
c790 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
c791 : 08              >            php         ;save flags
c792 : c001            >            cpy #1     ;test result
                       >            trap_ne
c794 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c796 : 68              >            pla         ;load status
c797 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c798 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c79a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c79c : 28              >            plp         ;restore status
                        
c79d : 88                       dey             ;00
                                tst_y 0,$ff-minus
c79e : 08              >            php         ;save flags
c79f : c000            >            cpy #0     ;test result
                       >            trap_ne
c7a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7a3 : 68              >            pla         ;load status
c7a4 : 48              >            pha
                       >            cmp_flag $ff-minus
c7a5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7a9 : 28              >            plp         ;restore status
                        
c7aa : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
c7ab : 08              >            php         ;save flags
c7ac : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c7ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7b0 : 68              >            pla         ;load status
c7b1 : 48              >            pha
                       >            cmp_flag $ff-zero
c7b2 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7b6 : 28              >            plp         ;restore status
                        
c7b7 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
c7b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c7ba : 48              >            pha         ;use stack to load status
c7bb : 28              >            plp
                        
c7bc : c8                       iny             ;ff
                                tst_y $ff,0+minus
c7bd : 08              >            php         ;save flags
c7be : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c7c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7c2 : 68              >            pla         ;load status
c7c3 : 48              >            pha
                       >            cmp_flag 0+minus
c7c4 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7c8 : 28              >            plp         ;restore status
                        
c7c9 : c8                       iny             ;00
                                tst_y 0,zero
c7ca : 08              >            php         ;save flags
c7cb : c000            >            cpy #0     ;test result
                       >            trap_ne
c7cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7cf : 68              >            pla         ;load status
c7d0 : 48              >            pha
                       >            cmp_flag zero
c7d1 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7d5 : 28              >            plp         ;restore status
                        
c7d6 : c8                       iny             ;01
                                tst_y 1,0
c7d7 : 08              >            php         ;save flags
c7d8 : c001            >            cpy #1     ;test result
                       >            trap_ne
c7da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7dc : 68              >            pla         ;load status
c7dd : 48              >            pha
                       >            cmp_flag 0
c7de : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7e2 : 28              >            plp         ;restore status
                        
c7e3 : 88                       dey             ;00
                                tst_y 0,zero
c7e4 : 08              >            php         ;save flags
c7e5 : c000            >            cpy #0     ;test result
                       >            trap_ne
c7e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7e9 : 68              >            pla         ;load status
c7ea : 48              >            pha
                       >            cmp_flag zero
c7eb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7ef : 28              >            plp         ;restore status
                        
c7f0 : 88                       dey             ;ff
                                tst_y $ff,minus
c7f1 : 08              >            php         ;save flags
c7f2 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c7f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7f6 : 68              >            pla         ;load status
c7f7 : 48              >            pha
                       >            cmp_flag minus
c7f8 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c7fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c7fc : 28              >            plp         ;restore status
                        
                        
c7fd : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
c7ff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c801 : 48              >            pha         ;use stack to load status
c802 : 28              >            plp
                        
c803 : 8a                       txa
                                tst_a $ff,$ff-zero
c804 : 08              >            php         ;save flags
c805 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c807 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c809 : 68              >            pla         ;load status
c80a : 48              >            pha
                       >            cmp_flag $ff-zero
c80b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c80d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c80f : 28              >            plp         ;restore status
                        
c810 : 08                       php
c811 : e8                       inx             ;00
c812 : 28                       plp
c813 : 8a                       txa
                                tst_a 0,$ff-minus
c814 : 08              >            php         ;save flags
c815 : c900            >            cmp #0     ;test result
                       >            trap_ne
c817 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c819 : 68              >            pla         ;load status
c81a : 48              >            pha
                       >            cmp_flag $ff-minus
c81b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c81d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c81f : 28              >            plp         ;restore status
                        
c820 : 08                       php
c821 : e8                       inx             ;01
c822 : 28                       plp
c823 : 8a                       txa
                                tst_a 1,$ff-minus-zero
c824 : 08              >            php         ;save flags
c825 : c901            >            cmp #1     ;test result
                       >            trap_ne
c827 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c829 : 68              >            pla         ;load status
c82a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c82b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c82d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c82f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
c830 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c832 : 48              >            pha         ;use stack to load status
c833 : 28              >            plp
                        
c834 : 8a                       txa
                                tst_a 1,0
c835 : 08              >            php         ;save flags
c836 : c901            >            cmp #1     ;test result
                       >            trap_ne
c838 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c83a : 68              >            pla         ;load status
c83b : 48              >            pha
                       >            cmp_flag 0
c83c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c83e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c840 : 28              >            plp         ;restore status
                        
c841 : 08                       php
c842 : ca                       dex             ;00
c843 : 28                       plp
c844 : 8a                       txa
                                tst_a 0,zero
c845 : 08              >            php         ;save flags
c846 : c900            >            cmp #0     ;test result
                       >            trap_ne
c848 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c84a : 68              >            pla         ;load status
c84b : 48              >            pha
                       >            cmp_flag zero
c84c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c84e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c850 : 28              >            plp         ;restore status
                        
c851 : 08                       php
c852 : ca                       dex             ;ff
c853 : 28                       plp
c854 : 8a                       txa
                                tst_a $ff,minus
c855 : 08              >            php         ;save flags
c856 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c858 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c85a : 68              >            pla         ;load status
c85b : 48              >            pha
                       >            cmp_flag minus
c85c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c85e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c860 : 28              >            plp         ;restore status
                        
                        
c861 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
c863 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c865 : 48              >            pha         ;use stack to load status
c866 : 28              >            plp
                        
c867 : 98                       tya
                                tst_a $ff,$ff-zero
c868 : 08              >            php         ;save flags
c869 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c86b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c86d : 68              >            pla         ;load status
c86e : 48              >            pha
                       >            cmp_flag $ff-zero
c86f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c871 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c873 : 28              >            plp         ;restore status
                        
c874 : 08                       php
c875 : c8                       iny             ;00
c876 : 28                       plp
c877 : 98                       tya
                                tst_a 0,$ff-minus
c878 : 08              >            php         ;save flags
c879 : c900            >            cmp #0     ;test result
                       >            trap_ne
c87b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c87d : 68              >            pla         ;load status
c87e : 48              >            pha
                       >            cmp_flag $ff-minus
c87f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c881 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c883 : 28              >            plp         ;restore status
                        
c884 : 08                       php
c885 : c8                       iny             ;01
c886 : 28                       plp
c887 : 98                       tya
                                tst_a 1,$ff-minus-zero
c888 : 08              >            php         ;save flags
c889 : c901            >            cmp #1     ;test result
                       >            trap_ne
c88b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c88d : 68              >            pla         ;load status
c88e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c88f : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c891 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c893 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
c894 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c896 : 48              >            pha         ;use stack to load status
c897 : 28              >            plp
                        
c898 : 98                       tya
                                tst_a 1,0
c899 : 08              >            php         ;save flags
c89a : c901            >            cmp #1     ;test result
                       >            trap_ne
c89c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c89e : 68              >            pla         ;load status
c89f : 48              >            pha
                       >            cmp_flag 0
c8a0 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8a4 : 28              >            plp         ;restore status
                        
c8a5 : 08                       php
c8a6 : 88                       dey             ;00
c8a7 : 28                       plp
c8a8 : 98                       tya
                                tst_a 0,zero
c8a9 : 08              >            php         ;save flags
c8aa : c900            >            cmp #0     ;test result
                       >            trap_ne
c8ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8ae : 68              >            pla         ;load status
c8af : 48              >            pha
                       >            cmp_flag zero
c8b0 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8b4 : 28              >            plp         ;restore status
                        
c8b5 : 08                       php
c8b6 : 88                       dey             ;ff
c8b7 : 28                       plp
c8b8 : 98                       tya
                                tst_a $ff,minus
c8b9 : 08              >            php         ;save flags
c8ba : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
c8bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8be : 68              >            pla         ;load status
c8bf : 48              >            pha
                       >            cmp_flag minus
c8c0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8c4 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
c8c5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
c8c7 : 48                       pha
c8c8 : a2ff                     ldx #$ff        ;ff
c8ca : 8a                       txa
c8cb : 28                       plp
c8cc : a8                       tay
                                tst_y $ff,$ff-zero
c8cd : 08              >            php         ;save flags
c8ce : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c8d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8d2 : 68              >            pla         ;load status
c8d3 : 48              >            pha
                       >            cmp_flag $ff-zero
c8d4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8d8 : 28              >            plp         ;restore status
                        
c8d9 : 08                       php
c8da : e8                       inx             ;00
c8db : 8a                       txa
c8dc : 28                       plp
c8dd : a8                       tay
                                tst_y 0,$ff-minus
c8de : 08              >            php         ;save flags
c8df : c000            >            cpy #0     ;test result
                       >            trap_ne
c8e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8e3 : 68              >            pla         ;load status
c8e4 : 48              >            pha
                       >            cmp_flag $ff-minus
c8e5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8e9 : 28              >            plp         ;restore status
                        
c8ea : 08                       php
c8eb : e8                       inx             ;01
c8ec : 8a                       txa
c8ed : 28                       plp
c8ee : a8                       tay
                                tst_y 1,$ff-minus-zero
c8ef : 08              >            php         ;save flags
c8f0 : c001            >            cpy #1     ;test result
                       >            trap_ne
c8f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8f4 : 68              >            pla         ;load status
c8f5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c8f6 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c8f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c8fa : 28              >            plp         ;restore status
                        
                                load_flag 0
c8fb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
c8fd : 48                       pha
c8fe : a900                     lda #0
c900 : 8a                       txa
c901 : 28                       plp
c902 : a8                       tay
                                tst_y 1,0
c903 : 08              >            php         ;save flags
c904 : c001            >            cpy #1     ;test result
                       >            trap_ne
c906 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c908 : 68              >            pla         ;load status
c909 : 48              >            pha
                       >            cmp_flag 0
c90a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c90c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c90e : 28              >            plp         ;restore status
                        
c90f : 08                       php
c910 : ca                       dex             ;00
c911 : 8a                       txa
c912 : 28                       plp
c913 : a8                       tay
                                tst_y 0,zero
c914 : 08              >            php         ;save flags
c915 : c000            >            cpy #0     ;test result
                       >            trap_ne
c917 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c919 : 68              >            pla         ;load status
c91a : 48              >            pha
                       >            cmp_flag zero
c91b : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c91d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c91f : 28              >            plp         ;restore status
                        
c920 : 08                       php
c921 : ca                       dex             ;ff
c922 : 8a                       txa
c923 : 28                       plp
c924 : a8                       tay
                                tst_y $ff,minus
c925 : 08              >            php         ;save flags
c926 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
c928 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c92a : 68              >            pla         ;load status
c92b : 48              >            pha
                       >            cmp_flag minus
c92c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c92e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c930 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
c931 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
c933 : 48                       pha
c934 : a0ff                     ldy #$ff        ;ff
c936 : 98                       tya
c937 : 28                       plp
c938 : aa                       tax
                                tst_x $ff,$ff-zero
c939 : 08              >            php         ;save flags
c93a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c93c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c93e : 68              >            pla         ;load status
c93f : 48              >            pha
                       >            cmp_flag $ff-zero
c940 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c942 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c944 : 28              >            plp         ;restore status
                        
c945 : 08                       php
c946 : c8                       iny             ;00
c947 : 98                       tya
c948 : 28                       plp
c949 : aa                       tax
                                tst_x 0,$ff-minus
c94a : 08              >            php         ;save flags
c94b : e000            >            cpx #0     ;test result
                       >            trap_ne
c94d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c94f : 68              >            pla         ;load status
c950 : 48              >            pha
                       >            cmp_flag $ff-minus
c951 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c953 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c955 : 28              >            plp         ;restore status
                        
c956 : 08                       php
c957 : c8                       iny             ;01
c958 : 98                       tya
c959 : 28                       plp
c95a : aa                       tax
                                tst_x 1,$ff-minus-zero
c95b : 08              >            php         ;save flags
c95c : e001            >            cpx #1     ;test result
                       >            trap_ne
c95e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c960 : 68              >            pla         ;load status
c961 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
c962 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c964 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c966 : 28              >            plp         ;restore status
                        
                                load_flag 0
c967 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
c969 : 48                       pha
c96a : a900                     lda #0          ;preset status
c96c : 98                       tya
c96d : 28                       plp
c96e : aa                       tax
                                tst_x 1,0
c96f : 08              >            php         ;save flags
c970 : e001            >            cpx #1     ;test result
                       >            trap_ne
c972 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c974 : 68              >            pla         ;load status
c975 : 48              >            pha
                       >            cmp_flag 0
c976 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c978 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c97a : 28              >            plp         ;restore status
                        
c97b : 08                       php
c97c : 88                       dey             ;00
c97d : 98                       tya
c97e : 28                       plp
c97f : aa                       tax
                                tst_x 0,zero
c980 : 08              >            php         ;save flags
c981 : e000            >            cpx #0     ;test result
                       >            trap_ne
c983 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c985 : 68              >            pla         ;load status
c986 : 48              >            pha
                       >            cmp_flag zero
c987 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c989 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c98b : 28              >            plp         ;restore status
                        
c98c : 08                       php
c98d : 88                       dey             ;ff
c98e : 98                       tya
c98f : 28                       plp
c990 : aa                       tax
                                tst_x $ff,minus
c991 : 08              >            php         ;save flags
c992 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
c994 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c996 : 68              >            pla         ;load status
c997 : 48              >            pha
                       >            cmp_flag minus
c998 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
c99a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
c99c : 28              >            plp         ;restore status
                        
                                next_test
c99d : ad0002          >            lda test_case   ;previous test
c9a0 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
c9a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
c9a4 : a90e            >            lda #test_num   ;*** next tests' number
c9a6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
c9a9 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
c9ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c9ad : 48              >            pha         ;use stack to load status
c9ae : 28              >            plp
                        
c9af : 9a                       txs
c9b0 : 08                       php
c9b1 : ad0101                   lda $101
                                cmp_flag $ff
c9b4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c9b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
c9b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c9ba : 48              >            pha         ;use stack to load status
c9bb : 28              >            plp
                        
c9bc : 9a                       txs
c9bd : 08                       php
c9be : ad0101                   lda $101
                                cmp_flag 0
c9c1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c9c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
c9c5 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
c9c6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c9c8 : 48              >            pha         ;use stack to load status
c9c9 : 28              >            plp
                        
c9ca : 9a                       txs
c9cb : 08                       php
c9cc : ad0001                   lda $100
                                cmp_flag $ff
c9cf : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c9d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
c9d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c9d5 : 48              >            pha         ;use stack to load status
c9d6 : 28              >            plp
                        
c9d7 : 9a                       txs
c9d8 : 08                       php
c9d9 : ad0001                   lda $100
                                cmp_flag 0
c9dc : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c9de : d0fe            >        bne *           ;failed not equal (non zero)
                        
c9e0 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
c9e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c9e3 : 48              >            pha         ;use stack to load status
c9e4 : 28              >            plp
                        
c9e5 : 9a                       txs
c9e6 : 08                       php
c9e7 : adff01                   lda $1ff
                                cmp_flag $ff
c9ea : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
c9ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
c9ee : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
c9f0 : 48              >            pha         ;use stack to load status
c9f1 : 28              >            plp
                        
c9f2 : 9a                       txs
c9f3 : 08                       php
c9f4 : adff01                   lda $1ff
                                cmp_flag 0
c9f7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                        
c9f9 : a201                     ldx #1
c9fb : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
c9fc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
c9fe : 48              >            pha         ;use stack to load status
c9ff : 28              >            plp
                        
ca00 : ba                       tsx             ;clears Z, N
ca01 : 08                       php             ;sp=00
ca02 : e001                     cpx #1
                                trap_ne
ca04 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca06 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
ca09 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ca0d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ca0f : 48              >            pha         ;use stack to load status
ca10 : 28              >            plp
                        
ca11 : ba                       tsx             ;clears N, sets Z
ca12 : 08                       php             ;sp=ff
ca13 : e000                     cpx #0
                                trap_ne
ca15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca17 : ad0001                   lda $100
                                cmp_flag $ff-minus
ca1a : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca1c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ca1e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ca20 : 48              >            pha         ;use stack to load status
ca21 : 28              >            plp
                        
ca22 : ba                       tsx             ;clears N, sets Z
ca23 : 08                       php             ;sp=fe
ca24 : e0ff                     cpx #$ff
                                trap_ne
ca26 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca28 : adff01                   lda $1ff
                                cmp_flag $ff-zero
ca2b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca2d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
ca2f : a201                     ldx #1
ca31 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
ca32 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ca34 : 48              >            pha         ;use stack to load status
ca35 : 28              >            plp
                        
ca36 : ba                       tsx             ;clears Z, N
ca37 : 08                       php             ;sp=00
ca38 : e001                     cpx #1
                                trap_ne
ca3a : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca3c : ad0101                   lda $101
                                cmp_flag 0
ca3f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca41 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ca43 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ca45 : 48              >            pha         ;use stack to load status
ca46 : 28              >            plp
                        
ca47 : ba                       tsx             ;clears N, sets Z
ca48 : 08                       php             ;sp=ff
ca49 : e000                     cpx #0
                                trap_ne
ca4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca4d : ad0001                   lda $100
                                cmp_flag zero
ca50 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca52 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ca54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ca56 : 48              >            pha         ;use stack to load status
ca57 : 28              >            plp
                        
ca58 : ba                       tsx             ;clears N, sets Z
ca59 : 08                       php             ;sp=fe
ca5a : e0ff                     cpx #$ff
                                trap_ne
ca5c : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca5e : adff01                   lda $1ff
                                cmp_flag minus
ca61 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
ca63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca65 : 68                       pla             ;sp=ff
                                next_test
ca66 : ad0002          >            lda test_case   ;previous test
ca69 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ca6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
ca6d : a90f            >            lda #test_num   ;*** next tests' number
ca6f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
ca72 : a003                     ldy #3
ca74 :                  tldx
                                set_stat 0
                       >            load_flag 0
ca74 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ca76 : 48              >            pha         ;use stack to load status
ca77 : 28              >            plp
                        
ca78 : b65b                     ldx zp1,y
ca7a : 08                       php         ;test stores do not alter flags
ca7b : 8a                       txa
ca7c : 49c3                     eor #$c3
ca7e : 28                       plp
ca7f : 990302                   sta abst,y
ca82 : 08                       php         ;flags after load/store sequence
ca83 : 49c3                     eor #$c3
ca85 : d91802                   cmp abs1,y  ;test result
                                trap_ne
ca88 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca8a : 68                       pla         ;load status
                                eor_flag 0
ca8b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ca8d : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
ca90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ca92 : 88                       dey
ca93 : 10df                     bpl tldx
                        
ca95 : a003                     ldy #3
ca97 :                  tldx1
                                set_stat $ff
                       >            load_flag $ff
ca97 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ca99 : 48              >            pha         ;use stack to load status
ca9a : 28              >            plp
                        
ca9b : b65b                     ldx zp1,y
ca9d : 08                       php         ;test stores do not alter flags
ca9e : 8a                       txa
ca9f : 49c3                     eor #$c3
caa1 : 28                       plp
caa2 : 990302                   sta abst,y
caa5 : 08                       php         ;flags after load/store sequence
caa6 : 49c3                     eor #$c3
caa8 : d91802                   cmp abs1,y  ;test result
                                trap_ne
caab : d0fe            >        bne *           ;failed not equal (non zero)
                        
caad : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
caae : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cab0 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
cab3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cab5 : 88                       dey
cab6 : 10df                     bpl tldx1
                        
cab8 : a003                     ldy #3
caba :                  tldx2
                                set_stat 0
                       >            load_flag 0
caba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cabc : 48              >            pha         ;use stack to load status
cabd : 28              >            plp
                        
cabe : be1802                   ldx abs1,y
cac1 : 08                       php         ;test stores do not alter flags
cac2 : 8a                       txa
cac3 : 49c3                     eor #$c3
cac5 : aa                       tax
cac6 : 28                       plp
cac7 : 9652                     stx zpt,y
cac9 : 08                       php         ;flags after load/store sequence
caca : 49c3                     eor #$c3
cacc : d95b00                   cmp zp1,y   ;test result
                                trap_ne
cacf : d0fe            >        bne *           ;failed not equal (non zero)
                        
cad1 : 68                       pla         ;load status
                                eor_flag 0
cad2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cad4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
cad7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cad9 : 88                       dey
cada : 10de                     bpl tldx2
                        
cadc : a003                     ldy #3
cade :                  tldx3
                                set_stat $ff
                       >            load_flag $ff
cade : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cae0 : 48              >            pha         ;use stack to load status
cae1 : 28              >            plp
                        
cae2 : be1802                   ldx abs1,y
cae5 : 08                       php         ;test stores do not alter flags
cae6 : 8a                       txa
cae7 : 49c3                     eor #$c3
cae9 : aa                       tax
caea : 28                       plp
caeb : 9652                     stx zpt,y
caed : 08                       php         ;flags after load/store sequence
caee : 49c3                     eor #$c3
caf0 : d95b00                   cmp zp1,y   ;test result
                                trap_ne
caf3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
caf5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
caf6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
caf8 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
cafb : d0fe            >        bne *           ;failed not equal (non zero)
                        
cafd : 88                       dey
cafe : 10de                     bpl tldx3
                        
cb00 : a003                     ldy #3      ;testing store result
cb02 : a200                     ldx #0
cb04 : b95200           tstx    lda zpt,y
cb07 : 49c3                     eor #$c3
cb09 : d95b00                   cmp zp1,y
                                trap_ne     ;store to zp data
cb0c : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb0e : 9652                     stx zpt,y   ;clear
cb10 : b90302                   lda abst,y
cb13 : 49c3                     eor #$c3
cb15 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
cb18 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb1a : 8a                       txa
cb1b : 990302                   sta abst,y  ;clear
cb1e : 88                       dey
cb1f : 10e3                     bpl tstx
                                next_test
cb21 : ad0002          >            lda test_case   ;previous test
cb24 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
cb26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
cb28 : a910            >            lda #test_num   ;*** next tests' number
cb2a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
cb2d : a0fd                     ldy #3+$fa
cb2f : b661             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
cb31 : 8a                       txa
cb32 : 990901                   sta abst-$fa,y      ;no STX abs,y!
cb35 : 88                       dey
cb36 : c0fa                     cpy #$fa
cb38 : b0f5                     bcs tldx4
cb3a : a0fd                     ldy #3+$fa
cb3c : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
cb3f : 9658                     stx zpt-$fa&$ff,y
cb41 : 88                       dey
cb42 : c0fa                     cpy #$fa
cb44 : b0f6                     bcs tldx5
cb46 : a003                     ldy #3      ;testing wraparound result
cb48 : a200                     ldx #0
cb4a : b95200           tstx1   lda zpt,y
cb4d : d95b00                   cmp zp1,y
                                trap_ne     ;store to zp data
cb50 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb52 : 9652                     stx zpt,y   ;clear
cb54 : b90302                   lda abst,y
cb57 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
cb5a : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb5c : 8a                       txa
cb5d : 990302                   sta abst,y  ;clear
cb60 : 88                       dey
cb61 : 10e7                     bpl tstx1
                                next_test
cb63 : ad0002          >            lda test_case   ;previous test
cb66 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
cb68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
cb6a : a911            >            lda #test_num   ;*** next tests' number
cb6c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp,x / abs,x
cb6f : a203                     ldx #3
cb71 :                  tldy
                                set_stat 0
                       >            load_flag 0
cb71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cb73 : 48              >            pha         ;use stack to load status
cb74 : 28              >            plp
                        
cb75 : b45b                     ldy zp1,x
cb77 : 08                       php         ;test stores do not alter flags
cb78 : 98                       tya
cb79 : 49c3                     eor #$c3
cb7b : 28                       plp
cb7c : 9d0302                   sta abst,x
cb7f : 08                       php         ;flags after load/store sequence
cb80 : 49c3                     eor #$c3
cb82 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
cb85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb87 : 68                       pla         ;load status
                                eor_flag 0
cb88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cb8a : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
cb8d : d0fe            >        bne *           ;failed not equal (non zero)
                        
cb8f : ca                       dex
cb90 : 10df                     bpl tldy
                        
cb92 : a203                     ldx #3
cb94 :                  tldy1
                                set_stat $ff
                       >            load_flag $ff
cb94 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cb96 : 48              >            pha         ;use stack to load status
cb97 : 28              >            plp
                        
cb98 : b45b                     ldy zp1,x
cb9a : 08                       php         ;test stores do not alter flags
cb9b : 98                       tya
cb9c : 49c3                     eor #$c3
cb9e : 28                       plp
cb9f : 9d0302                   sta abst,x
cba2 : 08                       php         ;flags after load/store sequence
cba3 : 49c3                     eor #$c3
cba5 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
cba8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbaa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cbab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cbad : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
cbb0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbb2 : ca                       dex
cbb3 : 10df                     bpl tldy1
                        
cbb5 : a203                     ldx #3
cbb7 :                  tldy2
                                set_stat 0
                       >            load_flag 0
cbb7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cbb9 : 48              >            pha         ;use stack to load status
cbba : 28              >            plp
                        
cbbb : bc1802                   ldy abs1,x
cbbe : 08                       php         ;test stores do not alter flags
cbbf : 98                       tya
cbc0 : 49c3                     eor #$c3
cbc2 : a8                       tay
cbc3 : 28                       plp
cbc4 : 9452                     sty zpt,x
cbc6 : 08                       php         ;flags after load/store sequence
cbc7 : 49c3                     eor #$c3
cbc9 : d55b                     cmp zp1,x   ;test result
                                trap_ne
cbcb : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbcd : 68                       pla         ;load status
                                eor_flag 0
cbce : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cbd0 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
cbd3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbd5 : ca                       dex
cbd6 : 10df                     bpl tldy2
                        
cbd8 : a203                     ldx #3
cbda :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
cbda : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cbdc : 48              >            pha         ;use stack to load status
cbdd : 28              >            plp
                        
cbde : bc1802                   ldy abs1,x
cbe1 : 08                       php         ;test stores do not alter flags
cbe2 : 98                       tya
cbe3 : 49c3                     eor #$c3
cbe5 : a8                       tay
cbe6 : 28                       plp
cbe7 : 9452                     sty zpt,x
cbe9 : 08                       php         ;flags after load/store sequence
cbea : 49c3                     eor #$c3
cbec : d55b                     cmp zp1,x   ;test result
                                trap_ne
cbee : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbf0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cbf1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cbf3 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
cbf6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cbf8 : ca                       dex
cbf9 : 10df                     bpl tldy3
                        
cbfb : a203                     ldx #3      ;testing store result
cbfd : a000                     ldy #0
cbff : b552             tsty    lda zpt,x
cc01 : 49c3                     eor #$c3
cc03 : d55b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
cc05 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc07 : 9452                     sty zpt,x   ;clear
cc09 : bd0302                   lda abst,x
cc0c : 49c3                     eor #$c3
cc0e : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
cc11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc13 : 8a                       txa
cc14 : 9d0302                   sta abst,x  ;clear
cc17 : ca                       dex
cc18 : 10e5                     bpl tsty
                                next_test
cc1a : ad0002          >            lda test_case   ;previous test
cc1d : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
cc1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
cc21 : a912            >            lda #test_num   ;*** next tests' number
cc23 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
cc26 : a2fd                     ldx #3+$fa
cc28 : b461             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
cc2a : 98                       tya
cc2b : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
cc2e : ca                       dex
cc2f : e0fa                     cpx #$fa
cc31 : b0f5                     bcs tldy4
cc33 : a2fd                     ldx #3+$fa
cc35 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
cc38 : 9458                     sty zpt-$fa&$ff,x
cc3a : ca                       dex
cc3b : e0fa                     cpx #$fa
cc3d : b0f6                     bcs tldy5
cc3f : a203                     ldx #3      ;testing wraparound result
cc41 : a000                     ldy #0
cc43 : b552             tsty1   lda zpt,x
cc45 : d55b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
cc47 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc49 : 9452                     sty zpt,x   ;clear
cc4b : bd0302                   lda abst,x
cc4e : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
cc51 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc53 : 8a                       txa
cc54 : 9d0302                   sta abst,x  ;clear
cc57 : ca                       dex
cc58 : 10e9                     bpl tsty1
                                next_test
cc5a : ad0002          >            lda test_case   ;previous test
cc5d : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
cc5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
cc61 : a913            >            lda #test_num   ;*** next tests' number
cc63 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0
                       >            load_flag 0
cc66 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cc68 : 48              >            pha         ;use stack to load status
cc69 : 28              >            plp
                        
cc6a : a65b                     ldx zp1
cc6c : 08                       php         ;test stores do not alter flags
cc6d : 8a                       txa
cc6e : 49c3                     eor #$c3
cc70 : aa                       tax
cc71 : 28                       plp
cc72 : 8e0302                   stx abst
cc75 : 08                       php         ;flags after load/store sequence
cc76 : 49c3                     eor #$c3
cc78 : aa                       tax
cc79 : e0c3                     cpx #$c3    ;test result
                                trap_ne
cc7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc7d : 68                       pla         ;load status
                                eor_flag 0
cc7e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cc80 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
cc83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cc85 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cc87 : 48              >            pha         ;use stack to load status
cc88 : 28              >            plp
                        
cc89 : a65c                     ldx zp1+1
cc8b : 08                       php         ;test stores do not alter flags
cc8c : 8a                       txa
cc8d : 49c3                     eor #$c3
cc8f : aa                       tax
cc90 : 28                       plp
cc91 : 8e0402                   stx abst+1
cc94 : 08                       php         ;flags after load/store sequence
cc95 : 49c3                     eor #$c3
cc97 : aa                       tax
cc98 : e082                     cpx #$82    ;test result
                                trap_ne
cc9a : d0fe            >        bne *           ;failed not equal (non zero)
                        
cc9c : 68                       pla         ;load status
                                eor_flag 0
cc9d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cc9f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
cca2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cca4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cca6 : 48              >            pha         ;use stack to load status
cca7 : 28              >            plp
                        
cca8 : a65d                     ldx zp1+2
ccaa : 08                       php         ;test stores do not alter flags
ccab : 8a                       txa
ccac : 49c3                     eor #$c3
ccae : aa                       tax
ccaf : 28                       plp
ccb0 : 8e0502                   stx abst+2
ccb3 : 08                       php         ;flags after load/store sequence
ccb4 : 49c3                     eor #$c3
ccb6 : aa                       tax
ccb7 : e041                     cpx #$41    ;test result
                                trap_ne
ccb9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ccbb : 68                       pla         ;load status
                                eor_flag 0
ccbc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ccbe : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
ccc1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ccc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ccc5 : 48              >            pha         ;use stack to load status
ccc6 : 28              >            plp
                        
ccc7 : a65e                     ldx zp1+3
ccc9 : 08                       php         ;test stores do not alter flags
ccca : 8a                       txa
cccb : 49c3                     eor #$c3
cccd : aa                       tax
ccce : 28                       plp
cccf : 8e0602                   stx abst+3
ccd2 : 08                       php         ;flags after load/store sequence
ccd3 : 49c3                     eor #$c3
ccd5 : aa                       tax
ccd6 : e000                     cpx #0      ;test result
                                trap_ne
ccd8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ccda : 68                       pla         ;load status
                                eor_flag 0
ccdb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ccdd : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cce0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
cce2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cce4 : 48              >            pha         ;use stack to load status
cce5 : 28              >            plp
                        
cce6 : a65b                     ldx zp1
cce8 : 08                       php         ;test stores do not alter flags
cce9 : 8a                       txa
ccea : 49c3                     eor #$c3
ccec : aa                       tax
cced : 28                       plp
ccee : 8e0302                   stx abst
ccf1 : 08                       php         ;flags after load/store sequence
ccf2 : 49c3                     eor #$c3
ccf4 : aa                       tax
ccf5 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
ccf7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ccf9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ccfa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ccfc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
ccff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cd01 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cd03 : 48              >            pha         ;use stack to load status
cd04 : 28              >            plp
                        
cd05 : a65c                     ldx zp1+1
cd07 : 08                       php         ;test stores do not alter flags
cd08 : 8a                       txa
cd09 : 49c3                     eor #$c3
cd0b : aa                       tax
cd0c : 28                       plp
cd0d : 8e0402                   stx abst+1
cd10 : 08                       php         ;flags after load/store sequence
cd11 : 49c3                     eor #$c3
cd13 : aa                       tax
cd14 : e082                     cpx #$82    ;test result
                                trap_ne
cd16 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cd18 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cd19 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cd1b : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
cd1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cd20 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cd22 : 48              >            pha         ;use stack to load status
cd23 : 28              >            plp
                        
cd24 : a65d                     ldx zp1+2
cd26 : 08                       php         ;test stores do not alter flags
cd27 : 8a                       txa
cd28 : 49c3                     eor #$c3
cd2a : aa                       tax
cd2b : 28                       plp
cd2c : 8e0502                   stx abst+2
cd2f : 08                       php         ;flags after load/store sequence
cd30 : 49c3                     eor #$c3
cd32 : aa                       tax
cd33 : e041                     cpx #$41    ;test result
                                trap_ne     ;
cd35 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cd37 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cd38 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cd3a : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
cd3d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cd3f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cd41 : 48              >            pha         ;use stack to load status
cd42 : 28              >            plp
                        
cd43 : a65e                     ldx zp1+3
cd45 : 08                       php         ;test stores do not alter flags
cd46 : 8a                       txa
cd47 : 49c3                     eor #$c3
cd49 : aa                       tax
cd4a : 28                       plp
cd4b : 8e0602                   stx abst+3
cd4e : 08                       php         ;flags after load/store sequence
cd4f : 49c3                     eor #$c3
cd51 : aa                       tax
cd52 : e000                     cpx #0      ;test result
                                trap_ne
cd54 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cd56 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cd57 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cd59 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cd5c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
cd5e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cd60 : 48              >            pha         ;use stack to load status
cd61 : 28              >            plp
                        
cd62 : ae1802                   ldx abs1
cd65 : 08                       php         ;test stores do not alter flags
cd66 : 8a                       txa
cd67 : 49c3                     eor #$c3
cd69 : aa                       tax
cd6a : 28                       plp
cd6b : 8652                     stx zpt
cd6d : 08                       php         ;flags after load/store sequence
cd6e : 49c3                     eor #$c3
cd70 : c55b                     cmp zp1     ;test result
                                trap_ne
cd72 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cd74 : 68                       pla         ;load status
                                eor_flag 0
cd75 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cd77 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
cd7a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cd7c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cd7e : 48              >            pha         ;use stack to load status
cd7f : 28              >            plp
                        
cd80 : ae1902                   ldx abs1+1
cd83 : 08                       php         ;test stores do not alter flags
cd84 : 8a                       txa
cd85 : 49c3                     eor #$c3
cd87 : aa                       tax
cd88 : 28                       plp
cd89 : 8653                     stx zpt+1
cd8b : 08                       php         ;flags after load/store sequence
cd8c : 49c3                     eor #$c3
cd8e : c55c                     cmp zp1+1   ;test result
                                trap_ne
cd90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cd92 : 68                       pla         ;load status
                                eor_flag 0
cd93 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cd95 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
cd98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cd9a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cd9c : 48              >            pha         ;use stack to load status
cd9d : 28              >            plp
                        
cd9e : ae1a02                   ldx abs1+2
cda1 : 08                       php         ;test stores do not alter flags
cda2 : 8a                       txa
cda3 : 49c3                     eor #$c3
cda5 : aa                       tax
cda6 : 28                       plp
cda7 : 8654                     stx zpt+2
cda9 : 08                       php         ;flags after load/store sequence
cdaa : 49c3                     eor #$c3
cdac : c55d                     cmp zp1+2   ;test result
                                trap_ne
cdae : d0fe            >        bne *           ;failed not equal (non zero)
                        
cdb0 : 68                       pla         ;load status
                                eor_flag 0
cdb1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cdb3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
cdb6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cdb8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cdba : 48              >            pha         ;use stack to load status
cdbb : 28              >            plp
                        
cdbc : ae1b02                   ldx abs1+3
cdbf : 08                       php         ;test stores do not alter flags
cdc0 : 8a                       txa
cdc1 : 49c3                     eor #$c3
cdc3 : aa                       tax
cdc4 : 28                       plp
cdc5 : 8655                     stx zpt+3
cdc7 : 08                       php         ;flags after load/store sequence
cdc8 : 49c3                     eor #$c3
cdca : c55e                     cmp zp1+3   ;test result
                                trap_ne
cdcc : d0fe            >        bne *           ;failed not equal (non zero)
                        
cdce : 68                       pla         ;load status
                                eor_flag 0
cdcf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cdd1 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cdd4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
cdd6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cdd8 : 48              >            pha         ;use stack to load status
cdd9 : 28              >            plp
                        
cdda : ae1802                   ldx abs1
cddd : 08                       php         ;test stores do not alter flags
cdde : 8a                       txa
cddf : 49c3                     eor #$c3
cde1 : aa                       tax
cde2 : 28                       plp
cde3 : 8652                     stx zpt
cde5 : 08                       php         ;flags after load/store sequence
cde6 : 49c3                     eor #$c3
cde8 : aa                       tax
cde9 : e45b                     cpx zp1     ;test result
                                trap_ne
cdeb : d0fe            >        bne *           ;failed not equal (non zero)
                        
cded : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cdee : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cdf0 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
cdf3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cdf5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cdf7 : 48              >            pha         ;use stack to load status
cdf8 : 28              >            plp
                        
cdf9 : ae1902                   ldx abs1+1
cdfc : 08                       php         ;test stores do not alter flags
cdfd : 8a                       txa
cdfe : 49c3                     eor #$c3
ce00 : aa                       tax
ce01 : 28                       plp
ce02 : 8653                     stx zpt+1
ce04 : 08                       php         ;flags after load/store sequence
ce05 : 49c3                     eor #$c3
ce07 : aa                       tax
ce08 : e45c                     cpx zp1+1   ;test result
                                trap_ne
ce0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce0c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ce0d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ce0f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
ce12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ce14 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ce16 : 48              >            pha         ;use stack to load status
ce17 : 28              >            plp
                        
ce18 : ae1a02                   ldx abs1+2
ce1b : 08                       php         ;test stores do not alter flags
ce1c : 8a                       txa
ce1d : 49c3                     eor #$c3
ce1f : aa                       tax
ce20 : 28                       plp
ce21 : 8654                     stx zpt+2
ce23 : 08                       php         ;flags after load/store sequence
ce24 : 49c3                     eor #$c3
ce26 : aa                       tax
ce27 : e45d                     cpx zp1+2   ;test result
                                trap_ne
ce29 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce2b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ce2c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ce2e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
ce31 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ce33 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ce35 : 48              >            pha         ;use stack to load status
ce36 : 28              >            plp
                        
ce37 : ae1b02                   ldx abs1+3
ce3a : 08                       php         ;test stores do not alter flags
ce3b : 8a                       txa
ce3c : 49c3                     eor #$c3
ce3e : aa                       tax
ce3f : 28                       plp
ce40 : 8655                     stx zpt+3
ce42 : 08                       php         ;flags after load/store sequence
ce43 : 49c3                     eor #$c3
ce45 : aa                       tax
ce46 : e45e                     cpx zp1+3   ;test result
                                trap_ne
ce48 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce4a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ce4b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ce4d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
ce50 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
ce52 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ce54 : 48              >            pha         ;use stack to load status
ce55 : 28              >            plp
                        
ce56 : a2c3                     ldx #$c3
ce58 : 08                       php
ce59 : ec1802                   cpx abs1    ;test result
                                trap_ne
ce5c : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce5e : 68                       pla         ;load status
                                eor_flag 0
ce5f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ce61 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
ce64 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ce66 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ce68 : 48              >            pha         ;use stack to load status
ce69 : 28              >            plp
                        
ce6a : a282                     ldx #$82
ce6c : 08                       php
ce6d : ec1902                   cpx abs1+1  ;test result
                                trap_ne
ce70 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce72 : 68                       pla         ;load status
                                eor_flag 0
ce73 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ce75 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
ce78 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ce7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ce7c : 48              >            pha         ;use stack to load status
ce7d : 28              >            plp
                        
ce7e : a241                     ldx #$41
ce80 : 08                       php
ce81 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
ce84 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce86 : 68                       pla         ;load status
                                eor_flag 0
ce87 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ce89 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
ce8c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
ce8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ce90 : 48              >            pha         ;use stack to load status
ce91 : 28              >            plp
                        
ce92 : a200                     ldx #0
ce94 : 08                       php
ce95 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
ce98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ce9a : 68                       pla         ;load status
                                eor_flag 0
ce9b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
ce9d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cea0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
cea2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cea4 : 48              >            pha         ;use stack to load status
cea5 : 28              >            plp
                        
cea6 : a2c3                     ldx #$c3
cea8 : 08                       php
cea9 : ec1802                   cpx abs1    ;test result
                                trap_ne
ceac : d0fe            >        bne *           ;failed not equal (non zero)
                        
ceae : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ceaf : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ceb1 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
ceb4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ceb6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ceb8 : 48              >            pha         ;use stack to load status
ceb9 : 28              >            plp
                        
ceba : a282                     ldx #$82
cebc : 08                       php
cebd : ec1902                   cpx abs1+1  ;test result
                                trap_ne
cec0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cec2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cec3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cec5 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
cec8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
ceca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cecc : 48              >            pha         ;use stack to load status
cecd : 28              >            plp
                        
cece : a241                     ldx #$41
ced0 : 08                       php
ced1 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
ced4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ced6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ced7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ced9 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
cedc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cede : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cee0 : 48              >            pha         ;use stack to load status
cee1 : 28              >            plp
                        
cee2 : a200                     ldx #0
cee4 : 08                       php
cee5 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
cee8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
ceea : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
ceeb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
ceed : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cef0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
cef2 : a200                     ldx #0
cef4 : a552                     lda zpt
cef6 : 49c3                     eor #$c3
cef8 : c55b                     cmp zp1
                                trap_ne     ;store to zp data
cefa : d0fe            >        bne *           ;failed not equal (non zero)
                        
cefc : 8652                     stx zpt     ;clear
cefe : ad0302                   lda abst
cf01 : 49c3                     eor #$c3
cf03 : cd1802                   cmp abs1
                                trap_ne     ;store to abs data
cf06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf08 : 8e0302                   stx abst    ;clear
cf0b : a553                     lda zpt+1
cf0d : 49c3                     eor #$c3
cf0f : c55c                     cmp zp1+1
                                trap_ne     ;store to zp data
cf11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf13 : 8653                     stx zpt+1   ;clear
cf15 : ad0402                   lda abst+1
cf18 : 49c3                     eor #$c3
cf1a : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
cf1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf1f : 8e0402                   stx abst+1  ;clear
cf22 : a554                     lda zpt+2
cf24 : 49c3                     eor #$c3
cf26 : c55d                     cmp zp1+2
                                trap_ne     ;store to zp data
cf28 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf2a : 8654                     stx zpt+2   ;clear
cf2c : ad0502                   lda abst+2
cf2f : 49c3                     eor #$c3
cf31 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
cf34 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf36 : 8e0502                   stx abst+2  ;clear
cf39 : a555                     lda zpt+3
cf3b : 49c3                     eor #$c3
cf3d : c55e                     cmp zp1+3
                                trap_ne     ;store to zp data
cf3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf41 : 8655                     stx zpt+3   ;clear
cf43 : ad0602                   lda abst+3
cf46 : 49c3                     eor #$c3
cf48 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
cf4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf4d : 8e0602                   stx abst+3  ;clear
                                next_test
cf50 : ad0002          >            lda test_case   ;previous test
cf53 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
cf55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
cf57 : a914            >            lda #test_num   ;*** next tests' number
cf59 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
cf5c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cf5e : 48              >            pha         ;use stack to load status
cf5f : 28              >            plp
                        
cf60 : a45b                     ldy zp1
cf62 : 08                       php         ;test stores do not alter flags
cf63 : 98                       tya
cf64 : 49c3                     eor #$c3
cf66 : a8                       tay
cf67 : 28                       plp
cf68 : 8c0302                   sty abst
cf6b : 08                       php         ;flags after load/store sequence
cf6c : 49c3                     eor #$c3
cf6e : a8                       tay
cf6f : c0c3                     cpy #$c3    ;test result
                                trap_ne
cf71 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf73 : 68                       pla         ;load status
                                eor_flag 0
cf74 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cf76 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
cf79 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cf7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cf7d : 48              >            pha         ;use stack to load status
cf7e : 28              >            plp
                        
cf7f : a45c                     ldy zp1+1
cf81 : 08                       php         ;test stores do not alter flags
cf82 : 98                       tya
cf83 : 49c3                     eor #$c3
cf85 : a8                       tay
cf86 : 28                       plp
cf87 : 8c0402                   sty abst+1
cf8a : 08                       php         ;flags after load/store sequence
cf8b : 49c3                     eor #$c3
cf8d : a8                       tay
cf8e : c082                     cpy #$82    ;test result
                                trap_ne
cf90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
cf92 : 68                       pla         ;load status
                                eor_flag 0
cf93 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cf95 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
cf98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cf9a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cf9c : 48              >            pha         ;use stack to load status
cf9d : 28              >            plp
                        
cf9e : a45d                     ldy zp1+2
cfa0 : 08                       php         ;test stores do not alter flags
cfa1 : 98                       tya
cfa2 : 49c3                     eor #$c3
cfa4 : a8                       tay
cfa5 : 28                       plp
cfa6 : 8c0502                   sty abst+2
cfa9 : 08                       php         ;flags after load/store sequence
cfaa : 49c3                     eor #$c3
cfac : a8                       tay
cfad : c041                     cpy #$41    ;test result
                                trap_ne
cfaf : d0fe            >        bne *           ;failed not equal (non zero)
                        
cfb1 : 68                       pla         ;load status
                                eor_flag 0
cfb2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cfb4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
cfb7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
cfb9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
cfbb : 48              >            pha         ;use stack to load status
cfbc : 28              >            plp
                        
cfbd : a45e                     ldy zp1+3
cfbf : 08                       php         ;test stores do not alter flags
cfc0 : 98                       tya
cfc1 : 49c3                     eor #$c3
cfc3 : a8                       tay
cfc4 : 28                       plp
cfc5 : 8c0602                   sty abst+3
cfc8 : 08                       php         ;flags after load/store sequence
cfc9 : 49c3                     eor #$c3
cfcb : a8                       tay
cfcc : c000                     cpy #0      ;test result
                                trap_ne
cfce : d0fe            >        bne *           ;failed not equal (non zero)
                        
cfd0 : 68                       pla         ;load status
                                eor_flag 0
cfd1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
cfd3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
cfd6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
cfd8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cfda : 48              >            pha         ;use stack to load status
cfdb : 28              >            plp
                        
cfdc : a45b                     ldy zp1
cfde : 08                       php         ;test stores do not alter flags
cfdf : 98                       tya
cfe0 : 49c3                     eor #$c3
cfe2 : a8                       tay
cfe3 : 28                       plp
cfe4 : 8c0302                   sty abst
cfe7 : 08                       php         ;flags after load/store sequence
cfe8 : 49c3                     eor #$c3
cfea : a8                       tay
cfeb : c0c3                     cpy #$c3    ;test result
                                trap_ne
cfed : d0fe            >        bne *           ;failed not equal (non zero)
                        
cfef : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
cff0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
cff2 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
cff5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
cff7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
cff9 : 48              >            pha         ;use stack to load status
cffa : 28              >            plp
                        
cffb : a45c                     ldy zp1+1
cffd : 08                       php         ;test stores do not alter flags
cffe : 98                       tya
cfff : 49c3                     eor #$c3
d001 : a8                       tay
d002 : 28                       plp
d003 : 8c0402                   sty abst+1
d006 : 08                       php         ;flags after load/store sequence
d007 : 49c3                     eor #$c3
d009 : a8                       tay
d00a : c082                     cpy #$82   ;test result
                                trap_ne
d00c : d0fe            >        bne *           ;failed not equal (non zero)
                        
d00e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d00f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d011 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d014 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d016 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d018 : 48              >            pha         ;use stack to load status
d019 : 28              >            plp
                        
d01a : a45d                     ldy zp1+2
d01c : 08                       php         ;test stores do not alter flags
d01d : 98                       tya
d01e : 49c3                     eor #$c3
d020 : a8                       tay
d021 : 28                       plp
d022 : 8c0502                   sty abst+2
d025 : 08                       php         ;flags after load/store sequence
d026 : 49c3                     eor #$c3
d028 : a8                       tay
d029 : c041                     cpy #$41    ;test result
                                trap_ne
d02b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d02d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d02e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d030 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d033 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d035 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d037 : 48              >            pha         ;use stack to load status
d038 : 28              >            plp
                        
d039 : a45e                     ldy zp1+3
d03b : 08                       php         ;test stores do not alter flags
d03c : 98                       tya
d03d : 49c3                     eor #$c3
d03f : a8                       tay
d040 : 28                       plp
d041 : 8c0602                   sty abst+3
d044 : 08                       php         ;flags after load/store sequence
d045 : 49c3                     eor #$c3
d047 : a8                       tay
d048 : c000                     cpy #0      ;test result
                                trap_ne
d04a : d0fe            >        bne *           ;failed not equal (non zero)
                        
d04c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d04d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d04f : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d052 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
d054 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d056 : 48              >            pha         ;use stack to load status
d057 : 28              >            plp
                        
d058 : ac1802                   ldy abs1
d05b : 08                       php         ;test stores do not alter flags
d05c : 98                       tya
d05d : 49c3                     eor #$c3
d05f : a8                       tay
d060 : 28                       plp
d061 : 8452                     sty zpt
d063 : 08                       php         ;flags after load/store sequence
d064 : 49c3                     eor #$c3
d066 : a8                       tay
d067 : c45b                     cpy zp1     ;test result
                                trap_ne
d069 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d06b : 68                       pla         ;load status
                                eor_flag 0
d06c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d06e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d071 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d073 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d075 : 48              >            pha         ;use stack to load status
d076 : 28              >            plp
                        
d077 : ac1902                   ldy abs1+1
d07a : 08                       php         ;test stores do not alter flags
d07b : 98                       tya
d07c : 49c3                     eor #$c3
d07e : a8                       tay
d07f : 28                       plp
d080 : 8453                     sty zpt+1
d082 : 08                       php         ;flags after load/store sequence
d083 : 49c3                     eor #$c3
d085 : a8                       tay
d086 : c45c                     cpy zp1+1   ;test result
                                trap_ne
d088 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d08a : 68                       pla         ;load status
                                eor_flag 0
d08b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d08d : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d090 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d092 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d094 : 48              >            pha         ;use stack to load status
d095 : 28              >            plp
                        
d096 : ac1a02                   ldy abs1+2
d099 : 08                       php         ;test stores do not alter flags
d09a : 98                       tya
d09b : 49c3                     eor #$c3
d09d : a8                       tay
d09e : 28                       plp
d09f : 8454                     sty zpt+2
d0a1 : 08                       php         ;flags after load/store sequence
d0a2 : 49c3                     eor #$c3
d0a4 : a8                       tay
d0a5 : c45d                     cpy zp1+2   ;test result
                                trap_ne
d0a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d0a9 : 68                       pla         ;load status
                                eor_flag 0
d0aa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d0ac : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d0af : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d0b1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d0b3 : 48              >            pha         ;use stack to load status
d0b4 : 28              >            plp
                        
d0b5 : ac1b02                   ldy abs1+3
d0b8 : 08                       php         ;test stores do not alter flags
d0b9 : 98                       tya
d0ba : 49c3                     eor #$c3
d0bc : a8                       tay
d0bd : 28                       plp
d0be : 8455                     sty zpt+3
d0c0 : 08                       php         ;flags after load/store sequence
d0c1 : 49c3                     eor #$c3
d0c3 : a8                       tay
d0c4 : c45e                     cpy zp1+3   ;test result
                                trap_ne
d0c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d0c8 : 68                       pla         ;load status
                                eor_flag 0
d0c9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d0cb : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d0ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
d0d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d0d2 : 48              >            pha         ;use stack to load status
d0d3 : 28              >            plp
                        
d0d4 : ac1802                   ldy abs1
d0d7 : 08                       php         ;test stores do not alter flags
d0d8 : 98                       tya
d0d9 : 49c3                     eor #$c3
d0db : a8                       tay
d0dc : 28                       plp
d0dd : 8452                     sty zpt
d0df : 08                       php         ;flags after load/store sequence
d0e0 : 49c3                     eor #$c3
d0e2 : a8                       tay
d0e3 : c55b                     cmp zp1     ;test result
                                trap_ne
d0e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d0e7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d0e8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d0ea : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d0ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d0ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d0f1 : 48              >            pha         ;use stack to load status
d0f2 : 28              >            plp
                        
d0f3 : ac1902                   ldy abs1+1
d0f6 : 08                       php         ;test stores do not alter flags
d0f7 : 98                       tya
d0f8 : 49c3                     eor #$c3
d0fa : a8                       tay
d0fb : 28                       plp
d0fc : 8453                     sty zpt+1
d0fe : 08                       php         ;flags after load/store sequence
d0ff : 49c3                     eor #$c3
d101 : a8                       tay
d102 : c55c                     cmp zp1+1   ;test result
                                trap_ne
d104 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d106 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d107 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d109 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d10c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d10e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d110 : 48              >            pha         ;use stack to load status
d111 : 28              >            plp
                        
d112 : ac1a02                   ldy abs1+2
d115 : 08                       php         ;test stores do not alter flags
d116 : 98                       tya
d117 : 49c3                     eor #$c3
d119 : a8                       tay
d11a : 28                       plp
d11b : 8454                     sty zpt+2
d11d : 08                       php         ;flags after load/store sequence
d11e : 49c3                     eor #$c3
d120 : a8                       tay
d121 : c55d                     cmp zp1+2   ;test result
                                trap_ne
d123 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d125 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d126 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d128 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d12b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d12d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d12f : 48              >            pha         ;use stack to load status
d130 : 28              >            plp
                        
d131 : ac1b02                   ldy abs1+3
d134 : 08                       php         ;test stores do not alter flags
d135 : 98                       tya
d136 : 49c3                     eor #$c3
d138 : a8                       tay
d139 : 28                       plp
d13a : 8455                     sty zpt+3
d13c : 08                       php         ;flags after load/store sequence
d13d : 49c3                     eor #$c3
d13f : a8                       tay
d140 : c55e                     cmp zp1+3   ;test result
                                trap_ne
d142 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d144 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d145 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d147 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d14a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
d14c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d14e : 48              >            pha         ;use stack to load status
d14f : 28              >            plp
                        
d150 : a0c3                     ldy #$c3
d152 : 08                       php
d153 : cc1802                   cpy abs1    ;test result
                                trap_ne
d156 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d158 : 68                       pla         ;load status
                                eor_flag 0
d159 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d15b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d15e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d160 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d162 : 48              >            pha         ;use stack to load status
d163 : 28              >            plp
                        
d164 : a082                     ldy #$82
d166 : 08                       php
d167 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
d16a : d0fe            >        bne *           ;failed not equal (non zero)
                        
d16c : 68                       pla         ;load status
                                eor_flag 0
d16d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d16f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d172 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d174 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d176 : 48              >            pha         ;use stack to load status
d177 : 28              >            plp
                        
d178 : a041                     ldy #$41
d17a : 08                       php
d17b : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
d17e : d0fe            >        bne *           ;failed not equal (non zero)
                        
d180 : 68                       pla         ;load status
                                eor_flag 0
d181 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d183 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d186 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d188 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d18a : 48              >            pha         ;use stack to load status
d18b : 28              >            plp
                        
d18c : a000                     ldy #0
d18e : 08                       php
d18f : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
d192 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d194 : 68                       pla         ;load status
                                eor_flag 0
d195 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d197 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d19a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
d19c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d19e : 48              >            pha         ;use stack to load status
d19f : 28              >            plp
                        
d1a0 : a0c3                     ldy #$c3
d1a2 : 08                       php
d1a3 : cc1802                   cpy abs1    ;test result
                                trap_ne
d1a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d1a8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d1a9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d1ab : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d1ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d1b0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d1b2 : 48              >            pha         ;use stack to load status
d1b3 : 28              >            plp
                        
d1b4 : a082                     ldy #$82
d1b6 : 08                       php
d1b7 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
d1ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
d1bc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d1bd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d1bf : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d1c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d1c4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d1c6 : 48              >            pha         ;use stack to load status
d1c7 : 28              >            plp
                        
d1c8 : a041                     ldy #$41
d1ca : 08                       php
d1cb : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
d1ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
d1d0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d1d1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d1d3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d1d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d1d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d1da : 48              >            pha         ;use stack to load status
d1db : 28              >            plp
                        
d1dc : a000                     ldy #0
d1de : 08                       php
d1df : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
d1e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d1e4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d1e5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d1e7 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d1ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
d1ec : a000                     ldy #0
d1ee : a552                     lda zpt
d1f0 : 49c3                     eor #$c3
d1f2 : c55b                     cmp zp1
                                trap_ne     ;store to zp   data
d1f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d1f6 : 8452                     sty zpt     ;clear
d1f8 : ad0302                   lda abst
d1fb : 49c3                     eor #$c3
d1fd : cd1802                   cmp abs1
                                trap_ne     ;store to abs   data
d200 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d202 : 8c0302                   sty abst    ;clear
d205 : a553                     lda zpt+1
d207 : 49c3                     eor #$c3
d209 : c55c                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
d20b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d20d : 8453                     sty zpt+1   ;clear
d20f : ad0402                   lda abst+1
d212 : 49c3                     eor #$c3
d214 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
d217 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d219 : 8c0402                   sty abst+1  ;clear
d21c : a554                     lda zpt+2
d21e : 49c3                     eor #$c3
d220 : c55d                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
d222 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d224 : 8454                     sty zpt+2   ;clear
d226 : ad0502                   lda abst+2
d229 : 49c3                     eor #$c3
d22b : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
d22e : d0fe            >        bne *           ;failed not equal (non zero)
                        
d230 : 8c0502                   sty abst+2  ;clear
d233 : a555                     lda zpt+3
d235 : 49c3                     eor #$c3
d237 : c55e                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
d239 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d23b : 8455                     sty zpt+3   ;clear
d23d : ad0602                   lda abst+3
d240 : 49c3                     eor #$c3
d242 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
d245 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d247 : 8c0602                   sty abst+3  ;clear
                                next_test
d24a : ad0002          >            lda test_case   ;previous test
d24d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d24f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
d251 : a915            >            lda #test_num   ;*** next tests' number
d253 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
d256 : a203                     ldx #3
d258 :                  tldax
                                set_stat 0
                       >            load_flag 0
d258 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d25a : 48              >            pha         ;use stack to load status
d25b : 28              >            plp
                        
d25c : b55b                     lda zp1,x
d25e : 08                       php         ;test stores do not alter flags
d25f : 49c3                     eor #$c3
d261 : 28                       plp
d262 : 9d0302                   sta abst,x
d265 : 08                       php         ;flags after load/store sequence
d266 : 49c3                     eor #$c3
d268 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
d26b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d26d : 68                       pla         ;load status
                                eor_flag 0
d26e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d270 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
d273 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d275 : ca                       dex
d276 : 10e0                     bpl tldax
                        
d278 : a203                     ldx #3
d27a :                  tldax1
                                set_stat $ff
                       >            load_flag $ff
d27a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d27c : 48              >            pha         ;use stack to load status
d27d : 28              >            plp
                        
d27e : b55b                     lda zp1,x
d280 : 08                       php         ;test stores do not alter flags
d281 : 49c3                     eor #$c3
d283 : 28                       plp
d284 : 9d0302                   sta abst,x
d287 : 08                       php         ;flags after load/store sequence
d288 : 49c3                     eor #$c3
d28a : dd1802                   cmp abs1,x   ;test result
                                trap_ne
d28d : d0fe            >        bne *           ;failed not equal (non zero)
                        
d28f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d290 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d292 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
d295 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d297 : ca                       dex
d298 : 10e0                     bpl tldax1
                        
d29a : a203                     ldx #3
d29c :                  tldax2
                                set_stat 0
                       >            load_flag 0
d29c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d29e : 48              >            pha         ;use stack to load status
d29f : 28              >            plp
                        
d2a0 : bd1802                   lda abs1,x
d2a3 : 08                       php         ;test stores do not alter flags
d2a4 : 49c3                     eor #$c3
d2a6 : 28                       plp
d2a7 : 9552                     sta zpt,x
d2a9 : 08                       php         ;flags after load/store sequence
d2aa : 49c3                     eor #$c3
d2ac : d55b                     cmp zp1,x   ;test result
                                trap_ne
d2ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2b0 : 68                       pla         ;load status
                                eor_flag 0
d2b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d2b3 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
d2b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2b8 : ca                       dex
d2b9 : 10e1                     bpl tldax2
                        
d2bb : a203                     ldx #3
d2bd :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
d2bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d2bf : 48              >            pha         ;use stack to load status
d2c0 : 28              >            plp
                        
d2c1 : bd1802                   lda abs1,x
d2c4 : 08                       php         ;test stores do not alter flags
d2c5 : 49c3                     eor #$c3
d2c7 : 28                       plp
d2c8 : 9552                     sta zpt,x
d2ca : 08                       php         ;flags after load/store sequence
d2cb : 49c3                     eor #$c3
d2cd : d55b                     cmp zp1,x   ;test result
                                trap_ne
d2cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2d1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d2d2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d2d4 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
d2d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2d9 : ca                       dex
d2da : 10e1                     bpl tldax3
                        
d2dc : a203                     ldx #3      ;testing store result
d2de : a000                     ldy #0
d2e0 : b552             tstax   lda zpt,x
d2e2 : 49c3                     eor #$c3
d2e4 : d55b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
d2e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2e8 : 9452                     sty zpt,x   ;clear
d2ea : bd0302                   lda abst,x
d2ed : 49c3                     eor #$c3
d2ef : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
d2f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d2f4 : 8a                       txa
d2f5 : 9d0302                   sta abst,x  ;clear
d2f8 : ca                       dex
d2f9 : 10e5                     bpl tstax
                                next_test
d2fb : ad0002          >            lda test_case   ;previous test
d2fe : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d300 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
d302 : a916            >            lda #test_num   ;*** next tests' number
d304 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
d307 : a003                     ldy #3
d309 :                  tlday
                                set_stat 0
                       >            load_flag 0
d309 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d30b : 48              >            pha         ;use stack to load status
d30c : 28              >            plp
                        
d30d : b16c                     lda (ind1),y
d30f : 08                       php         ;test stores do not alter flags
d310 : 49c3                     eor #$c3
d312 : 28                       plp
d313 : 990302                   sta abst,y
d316 : 08                       php         ;flags after load/store sequence
d317 : 49c3                     eor #$c3
d319 : d91802                   cmp abs1,y  ;test result
                                trap_ne
d31c : d0fe            >        bne *           ;failed not equal (non zero)
                        
d31e : 68                       pla         ;load status
                                eor_flag 0
d31f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d321 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d324 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d326 : 88                       dey
d327 : 10e0                     bpl tlday
                        
d329 : a003                     ldy #3
d32b :                  tlday1
                                set_stat $ff
                       >            load_flag $ff
d32b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d32d : 48              >            pha         ;use stack to load status
d32e : 28              >            plp
                        
d32f : b16c                     lda (ind1),y
d331 : 08                       php         ;test stores do not alter flags
d332 : 49c3                     eor #$c3
d334 : 28                       plp
d335 : 990302                   sta abst,y
d338 : 08                       php         ;flags after load/store sequence
d339 : 49c3                     eor #$c3
d33b : d91802                   cmp abs1,y  ;test result
                                trap_ne
d33e : d0fe            >        bne *           ;failed not equal (non zero)
                        
d340 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d341 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d343 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d346 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d348 : 88                       dey
d349 : 10e0                     bpl tlday1
                        
d34b : a003                     ldy #3      ;testing store result
d34d : a200                     ldx #0
d34f : b90302           tstay   lda abst,y
d352 : 49c3                     eor #$c3
d354 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d357 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d359 : 8a                       txa
d35a : 990302                   sta abst,y  ;clear
d35d : 88                       dey
d35e : 10ef                     bpl tstay
                        
d360 : a003                     ldy #3
d362 :                  tlday2
                                set_stat 0
                       >            load_flag 0
d362 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d364 : 48              >            pha         ;use stack to load status
d365 : 28              >            plp
                        
d366 : b91802                   lda abs1,y
d369 : 08                       php         ;test stores do not alter flags
d36a : 49c3                     eor #$c3
d36c : 28                       plp
d36d : 9178                     sta (indt),y
d36f : 08                       php         ;flags after load/store sequence
d370 : 49c3                     eor #$c3
d372 : d16c                     cmp (ind1),y    ;test result
                                trap_ne
d374 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d376 : 68                       pla         ;load status
                                eor_flag 0
d377 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d379 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d37c : d0fe            >        bne *           ;failed not equal (non zero)
                        
d37e : 88                       dey
d37f : 10e1                     bpl tlday2
                        
d381 : a003                     ldy #3
d383 :                  tlday3
                                set_stat $ff
                       >            load_flag $ff
d383 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d385 : 48              >            pha         ;use stack to load status
d386 : 28              >            plp
                        
d387 : b91802                   lda abs1,y
d38a : 08                       php         ;test stores do not alter flags
d38b : 49c3                     eor #$c3
d38d : 28                       plp
d38e : 9178                     sta (indt),y
d390 : 08                       php         ;flags after load/store sequence
d391 : 49c3                     eor #$c3
d393 : d16c                     cmp (ind1),y   ;test result
                                trap_ne
d395 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d397 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d398 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d39a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d39d : d0fe            >        bne *           ;failed not equal (non zero)
                        
d39f : 88                       dey
d3a0 : 10e1                     bpl tlday3
                        
d3a2 : a003                     ldy #3      ;testing store result
d3a4 : a200                     ldx #0
d3a6 : b90302           tstay1  lda abst,y
d3a9 : 49c3                     eor #$c3
d3ab : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d3ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
d3b0 : 8a                       txa
d3b1 : 990302                   sta abst,y  ;clear
d3b4 : 88                       dey
d3b5 : 10ef                     bpl tstay1
                        
d3b7 : a206                     ldx #6
d3b9 : a003                     ldy #3
d3bb :                  tldax4
                                set_stat 0
                       >            load_flag 0
d3bb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d3bd : 48              >            pha         ;use stack to load status
d3be : 28              >            plp
                        
d3bf : a16c                     lda (ind1,x)
d3c1 : 08                       php         ;test stores do not alter flags
d3c2 : 49c3                     eor #$c3
d3c4 : 28                       plp
d3c5 : 8178                     sta (indt,x)
d3c7 : 08                       php         ;flags after load/store sequence
d3c8 : 49c3                     eor #$c3
d3ca : d91802                   cmp abs1,y  ;test result
                                trap_ne
d3cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
d3cf : 68                       pla         ;load status
                                eor_flag 0
d3d0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d3d2 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d3d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d3d7 : ca                       dex
d3d8 : ca                       dex
d3d9 : 88                       dey
d3da : 10df                     bpl tldax4
                        
d3dc : a206                     ldx #6
d3de : a003                     ldy #3
d3e0 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
d3e0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d3e2 : 48              >            pha         ;use stack to load status
d3e3 : 28              >            plp
                        
d3e4 : a16c                     lda (ind1,x)
d3e6 : 08                       php         ;test stores do not alter flags
d3e7 : 49c3                     eor #$c3
d3e9 : 28                       plp
d3ea : 8178                     sta (indt,x)
d3ec : 08                       php         ;flags after load/store sequence
d3ed : 49c3                     eor #$c3
d3ef : d91802                   cmp abs1,y  ;test result
                                trap_ne
d3f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d3f4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d3f5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d3f7 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
d3fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
d3fc : ca                       dex
d3fd : ca                       dex
d3fe : 88                       dey
d3ff : 10df                     bpl tldax5
                        
d401 : a003                     ldy #3      ;testing store result
d403 : a200                     ldx #0
d405 : b90302           tstay2  lda abst,y
d408 : 49c3                     eor #$c3
d40a : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d40d : d0fe            >        bne *           ;failed not equal (non zero)
                        
d40f : 8a                       txa
d410 : 990302                   sta abst,y  ;clear
d413 : 88                       dey
d414 : 10ef                     bpl tstay2
                                next_test
d416 : ad0002          >            lda test_case   ;previous test
d419 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d41b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
d41d : a917            >            lda #test_num   ;*** next tests' number
d41f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
d422 : a2fd                     ldx #3+$fa
d424 : b561             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
d426 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
d429 : ca                       dex
d42a : e0fa                     cpx #$fa
d42c : b0f6                     bcs tldax6
d42e : a2fd                     ldx #3+$fa
d430 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
d433 : 9558                     sta zpt-$fa&$ff,x
d435 : ca                       dex
d436 : e0fa                     cpx #$fa
d438 : b0f6                     bcs tldax7
                        
d43a : a203                     ldx #3      ;testing wraparound result
d43c : a000                     ldy #0
d43e : b552             tstax1  lda zpt,x
d440 : d55b                     cmp zp1,x
                                trap_ne     ;store to zp,x data
d442 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d444 : 9452                     sty zpt,x   ;clear
d446 : bd0302                   lda abst,x
d449 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
d44c : d0fe            >        bne *           ;failed not equal (non zero)
                        
d44e : 8a                       txa
d44f : 9d0302                   sta abst,x  ;clear
d452 : ca                       dex
d453 : 10e9                     bpl tstax1
                        
d455 : a0fb                     ldy #3+$f8
d457 : a2fe                     ldx #6+$f8
d459 : a174             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
d45b : 990b01                   sta abst-$f8,y
d45e : ca                       dex
d45f : ca                       dex
d460 : 88                       dey
d461 : c0f8                     cpy #$f8
d463 : b0f4                     bcs tlday4
d465 : a003                     ldy #3      ;testing wraparound result
d467 : a200                     ldx #0
d469 : b90302           tstay4  lda abst,y
d46c : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d46f : d0fe            >        bne *           ;failed not equal (non zero)
                        
d471 : 8a                       txa
d472 : 990302                   sta abst,y  ;clear
d475 : 88                       dey
d476 : 10f1                     bpl tstay4
                        
d478 : a0fb                     ldy #3+$f8
d47a : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
d47d : 9180                     sta (inwt),y
d47f : 88                       dey
d480 : c0f8                     cpy #$f8
d482 : b0f6                     bcs tlday5
d484 : a003                     ldy #3      ;testing wraparound result
d486 : a200                     ldx #0
d488 : b90302           tstay5  lda abst,y
d48b : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d48e : d0fe            >        bne *           ;failed not equal (non zero)
                        
d490 : 8a                       txa
d491 : 990302                   sta abst,y  ;clear
d494 : 88                       dey
d495 : 10f1                     bpl tstay5
                        
d497 : a0fb                     ldy #3+$f8
d499 : a2fe                     ldx #6+$f8
d49b : b176             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed
d49d : 8180                     sta (indt-$f8&$ff,x)
d49f : ca                       dex
d4a0 : ca                       dex
d4a1 : 88                       dey
d4a2 : c0f8                     cpy #$f8
d4a4 : b0f5                     bcs tlday6
d4a6 : a003                     ldy #3      ;testing wraparound result
d4a8 : a200                     ldx #0
d4aa : b90302           tstay6  lda abst,y
d4ad : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
d4b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d4b2 : 8a                       txa
d4b3 : 990302                   sta abst,y  ;clear
d4b6 : 88                       dey
d4b7 : 10f1                     bpl tstay6
                                next_test
d4b9 : ad0002          >            lda test_case   ;previous test
d4bc : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d4be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
d4c0 : a918            >            lda #test_num   ;*** next tests' number
d4c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0
                       >            load_flag 0
d4c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d4c7 : 48              >            pha         ;use stack to load status
d4c8 : 28              >            plp
                        
d4c9 : a55b                     lda zp1
d4cb : 08                       php         ;test stores do not alter flags
d4cc : 49c3                     eor #$c3
d4ce : 28                       plp
d4cf : 8d0302                   sta abst
d4d2 : 08                       php         ;flags after load/store sequence
d4d3 : 49c3                     eor #$c3
d4d5 : c9c3                     cmp #$c3    ;test result
                                trap_ne
d4d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d4d9 : 68                       pla         ;load status
                                eor_flag 0
d4da : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d4dc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d4df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d4e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d4e3 : 48              >            pha         ;use stack to load status
d4e4 : 28              >            plp
                        
d4e5 : a55c                     lda zp1+1
d4e7 : 08                       php         ;test stores do not alter flags
d4e8 : 49c3                     eor #$c3
d4ea : 28                       plp
d4eb : 8d0402                   sta abst+1
d4ee : 08                       php         ;flags after load/store sequence
d4ef : 49c3                     eor #$c3
d4f1 : c982                     cmp #$82    ;test result
                                trap_ne
d4f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d4f5 : 68                       pla         ;load status
                                eor_flag 0
d4f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d4f8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d4fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d4fd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d4ff : 48              >            pha         ;use stack to load status
d500 : 28              >            plp
                        
d501 : a55d                     lda zp1+2
d503 : 08                       php         ;test stores do not alter flags
d504 : 49c3                     eor #$c3
d506 : 28                       plp
d507 : 8d0502                   sta abst+2
d50a : 08                       php         ;flags after load/store sequence
d50b : 49c3                     eor #$c3
d50d : c941                     cmp #$41    ;test result
                                trap_ne
d50f : d0fe            >        bne *           ;failed not equal (non zero)
                        
d511 : 68                       pla         ;load status
                                eor_flag 0
d512 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d514 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d517 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d519 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d51b : 48              >            pha         ;use stack to load status
d51c : 28              >            plp
                        
d51d : a55e                     lda zp1+3
d51f : 08                       php         ;test stores do not alter flags
d520 : 49c3                     eor #$c3
d522 : 28                       plp
d523 : 8d0602                   sta abst+3
d526 : 08                       php         ;flags after load/store sequence
d527 : 49c3                     eor #$c3
d529 : c900                     cmp #0      ;test result
                                trap_ne
d52b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d52d : 68                       pla         ;load status
                                eor_flag 0
d52e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d530 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d533 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d535 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d537 : 48              >            pha         ;use stack to load status
d538 : 28              >            plp
                        
d539 : a55b                     lda zp1
d53b : 08                       php         ;test stores do not alter flags
d53c : 49c3                     eor #$c3
d53e : 28                       plp
d53f : 8d0302                   sta abst
d542 : 08                       php         ;flags after load/store sequence
d543 : 49c3                     eor #$c3
d545 : c9c3                     cmp #$c3    ;test result
                                trap_ne
d547 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d549 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d54a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d54c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d54f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d551 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d553 : 48              >            pha         ;use stack to load status
d554 : 28              >            plp
                        
d555 : a55c                     lda zp1+1
d557 : 08                       php         ;test stores do not alter flags
d558 : 49c3                     eor #$c3
d55a : 28                       plp
d55b : 8d0402                   sta abst+1
d55e : 08                       php         ;flags after load/store sequence
d55f : 49c3                     eor #$c3
d561 : c982                     cmp #$82    ;test result
                                trap_ne
d563 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d565 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d566 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d568 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d56b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d56d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d56f : 48              >            pha         ;use stack to load status
d570 : 28              >            plp
                        
d571 : a55d                     lda zp1+2
d573 : 08                       php         ;test stores do not alter flags
d574 : 49c3                     eor #$c3
d576 : 28                       plp
d577 : 8d0502                   sta abst+2
d57a : 08                       php         ;flags after load/store sequence
d57b : 49c3                     eor #$c3
d57d : c941                     cmp #$41    ;test result
                                trap_ne
d57f : d0fe            >        bne *           ;failed not equal (non zero)
                        
d581 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d582 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d584 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d587 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d589 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d58b : 48              >            pha         ;use stack to load status
d58c : 28              >            plp
                        
d58d : a55e                     lda zp1+3
d58f : 08                       php         ;test stores do not alter flags
d590 : 49c3                     eor #$c3
d592 : 28                       plp
d593 : 8d0602                   sta abst+3
d596 : 08                       php         ;flags after load/store sequence
d597 : 49c3                     eor #$c3
d599 : c900                     cmp #0      ;test result
                                trap_ne
d59b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d59d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d59e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d5a0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d5a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d5a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d5a7 : 48              >            pha         ;use stack to load status
d5a8 : 28              >            plp
                        
d5a9 : ad1802                   lda abs1
d5ac : 08                       php         ;test stores do not alter flags
d5ad : 49c3                     eor #$c3
d5af : 28                       plp
d5b0 : 8552                     sta zpt
d5b2 : 08                       php         ;flags after load/store sequence
d5b3 : 49c3                     eor #$c3
d5b5 : c55b                     cmp zp1     ;test result
                                trap_ne
d5b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d5b9 : 68                       pla         ;load status
                                eor_flag 0
d5ba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d5bc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d5bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d5c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d5c3 : 48              >            pha         ;use stack to load status
d5c4 : 28              >            plp
                        
d5c5 : ad1902                   lda abs1+1
d5c8 : 08                       php         ;test stores do not alter flags
d5c9 : 49c3                     eor #$c3
d5cb : 28                       plp
d5cc : 8553                     sta zpt+1
d5ce : 08                       php         ;flags after load/store sequence
d5cf : 49c3                     eor #$c3
d5d1 : c55c                     cmp zp1+1   ;test result
                                trap_ne
d5d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d5d5 : 68                       pla         ;load status
                                eor_flag 0
d5d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d5d8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d5db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d5dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d5df : 48              >            pha         ;use stack to load status
d5e0 : 28              >            plp
                        
d5e1 : ad1a02                   lda abs1+2
d5e4 : 08                       php         ;test stores do not alter flags
d5e5 : 49c3                     eor #$c3
d5e7 : 28                       plp
d5e8 : 8554                     sta zpt+2
d5ea : 08                       php         ;flags after load/store sequence
d5eb : 49c3                     eor #$c3
d5ed : c55d                     cmp zp1+2   ;test result
                                trap_ne
d5ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
d5f1 : 68                       pla         ;load status
                                eor_flag 0
d5f2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d5f4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d5f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d5f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d5fb : 48              >            pha         ;use stack to load status
d5fc : 28              >            plp
                        
d5fd : ad1b02                   lda abs1+3
d600 : 08                       php         ;test stores do not alter flags
d601 : 49c3                     eor #$c3
d603 : 28                       plp
d604 : 8555                     sta zpt+3
d606 : 08                       php         ;flags after load/store sequence
d607 : 49c3                     eor #$c3
d609 : c55e                     cmp zp1+3   ;test result
                                trap_ne
d60b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d60d : 68                       pla         ;load status
                                eor_flag 0
d60e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d610 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d613 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d615 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d617 : 48              >            pha         ;use stack to load status
d618 : 28              >            plp
                        
d619 : ad1802                   lda abs1
d61c : 08                       php         ;test stores do not alter flags
d61d : 49c3                     eor #$c3
d61f : 28                       plp
d620 : 8552                     sta zpt
d622 : 08                       php         ;flags after load/store sequence
d623 : 49c3                     eor #$c3
d625 : c55b                     cmp zp1     ;test result
                                trap_ne
d627 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d629 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d62a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d62c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d62f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d631 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d633 : 48              >            pha         ;use stack to load status
d634 : 28              >            plp
                        
d635 : ad1902                   lda abs1+1
d638 : 08                       php         ;test stores do not alter flags
d639 : 49c3                     eor #$c3
d63b : 28                       plp
d63c : 8553                     sta zpt+1
d63e : 08                       php         ;flags after load/store sequence
d63f : 49c3                     eor #$c3
d641 : c55c                     cmp zp1+1   ;test result
                                trap_ne
d643 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d645 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d646 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d648 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d64b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d64d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d64f : 48              >            pha         ;use stack to load status
d650 : 28              >            plp
                        
d651 : ad1a02                   lda abs1+2
d654 : 08                       php         ;test stores do not alter flags
d655 : 49c3                     eor #$c3
d657 : 28                       plp
d658 : 8554                     sta zpt+2
d65a : 08                       php         ;flags after load/store sequence
d65b : 49c3                     eor #$c3
d65d : c55d                     cmp zp1+2   ;test result
                                trap_ne
d65f : d0fe            >        bne *           ;failed not equal (non zero)
                        
d661 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d662 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d664 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d667 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d669 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d66b : 48              >            pha         ;use stack to load status
d66c : 28              >            plp
                        
d66d : ad1b02                   lda abs1+3
d670 : 08                       php         ;test stores do not alter flags
d671 : 49c3                     eor #$c3
d673 : 28                       plp
d674 : 8555                     sta zpt+3
d676 : 08                       php         ;flags after load/store sequence
d677 : 49c3                     eor #$c3
d679 : c55e                     cmp zp1+3   ;test result
                                trap_ne
d67b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d67d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d67e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d680 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d683 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d685 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d687 : 48              >            pha         ;use stack to load status
d688 : 28              >            plp
                        
d689 : a9c3                     lda #$c3
d68b : 08                       php
d68c : cd1802                   cmp abs1    ;test result
                                trap_ne
d68f : d0fe            >        bne *           ;failed not equal (non zero)
                        
d691 : 68                       pla         ;load status
                                eor_flag 0
d692 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d694 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d697 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d699 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d69b : 48              >            pha         ;use stack to load status
d69c : 28              >            plp
                        
d69d : a982                     lda #$82
d69f : 08                       php
d6a0 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
d6a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d6a5 : 68                       pla         ;load status
                                eor_flag 0
d6a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d6a8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d6ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d6ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d6af : 48              >            pha         ;use stack to load status
d6b0 : 28              >            plp
                        
d6b1 : a941                     lda #$41
d6b3 : 08                       php
d6b4 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
d6b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d6b9 : 68                       pla         ;load status
                                eor_flag 0
d6ba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d6bc : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d6bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
d6c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d6c3 : 48              >            pha         ;use stack to load status
d6c4 : 28              >            plp
                        
d6c5 : a900                     lda #0
d6c7 : 08                       php
d6c8 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
d6cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
d6cd : 68                       pla         ;load status
                                eor_flag 0
d6ce : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
d6d0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d6d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
d6d5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d6d7 : 48              >            pha         ;use stack to load status
d6d8 : 28              >            plp
                        
d6d9 : a9c3                     lda #$c3
d6db : 08                       php
d6dc : cd1802                   cmp abs1    ;test result
                                trap_ne
d6df : d0fe            >        bne *           ;failed not equal (non zero)
                        
d6e1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d6e2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d6e4 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
d6e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d6e9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d6eb : 48              >            pha         ;use stack to load status
d6ec : 28              >            plp
                        
d6ed : a982                     lda #$82
d6ef : 08                       php
d6f0 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
d6f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d6f5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d6f6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d6f8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
d6fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d6fd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d6ff : 48              >            pha         ;use stack to load status
d700 : 28              >            plp
                        
d701 : a941                     lda #$41
d703 : 08                       php
d704 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
d707 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d709 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d70a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d70c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
d70f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
d711 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d713 : 48              >            pha         ;use stack to load status
d714 : 28              >            plp
                        
d715 : a900                     lda #0
d717 : 08                       php
d718 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
d71b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d71d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
d71e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
d720 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
d723 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
d725 : a200                     ldx #0
d727 : a552                     lda zpt
d729 : 49c3                     eor #$c3
d72b : c55b                     cmp zp1
                                trap_ne     ;store to zp data
d72d : d0fe            >        bne *           ;failed not equal (non zero)
                        
d72f : 8652                     stx zpt     ;clear
d731 : ad0302                   lda abst
d734 : 49c3                     eor #$c3
d736 : cd1802                   cmp abs1
                                trap_ne     ;store to abs data
d739 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d73b : 8e0302                   stx abst    ;clear
d73e : a553                     lda zpt+1
d740 : 49c3                     eor #$c3
d742 : c55c                     cmp zp1+1
                                trap_ne     ;store to zp data
d744 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d746 : 8653                     stx zpt+1   ;clear
d748 : ad0402                   lda abst+1
d74b : 49c3                     eor #$c3
d74d : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
d750 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d752 : 8e0402                   stx abst+1  ;clear
d755 : a554                     lda zpt+2
d757 : 49c3                     eor #$c3
d759 : c55d                     cmp zp1+2
                                trap_ne     ;store to zp data
d75b : d0fe            >        bne *           ;failed not equal (non zero)
                        
d75d : 8654                     stx zpt+2   ;clear
d75f : ad0502                   lda abst+2
d762 : 49c3                     eor #$c3
d764 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
d767 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d769 : 8e0502                   stx abst+2  ;clear
d76c : a555                     lda zpt+3
d76e : 49c3                     eor #$c3
d770 : c55e                     cmp zp1+3
                                trap_ne     ;store to zp data
d772 : d0fe            >        bne *           ;failed not equal (non zero)
                        
d774 : 8655                     stx zpt+3   ;clear
d776 : ad0602                   lda abst+3
d779 : 49c3                     eor #$c3
d77b : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
d77e : d0fe            >        bne *           ;failed not equal (non zero)
                        
d780 : 8e0602                   stx abst+3  ;clear
                                next_test
d783 : ad0002          >            lda test_case   ;previous test
d786 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d788 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
d78a : a919            >            lda #test_num   ;*** next tests' number
d78c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
d78f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d791 : 48              >            pha         ;use stack to load status
d792 : a9ff            >            lda #$ff     ;precharge accu
d794 : 28              >            plp
                        
d795 : 245e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz
d797 : 08              >            php         ;save flags
d798 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
d79a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d79c : 68              >            pla         ;load status
d79d : 48              >            pha
                       >            cmp_flag fz
d79e : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d7a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7a2 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d7a3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d7a5 : 48              >            pha         ;use stack to load status
d7a6 : a901            >            lda #1     ;precharge accu
d7a8 : 28              >            plp
                        
d7a9 : 245d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
d7ab : 08              >            php         ;save flags
d7ac : c901            >            cmp #1     ;test result
                       >            trap_ne
d7ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7b0 : 68              >            pla         ;load status
d7b1 : 48              >            pha
                       >            cmp_flag fv
d7b2 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d7b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7b6 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d7b7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d7b9 : 48              >            pha         ;use stack to load status
d7ba : a901            >            lda #1     ;precharge accu
d7bc : 28              >            plp
                        
d7bd : 245c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
d7bf : 08              >            php         ;save flags
d7c0 : c901            >            cmp #1     ;test result
                       >            trap_ne
d7c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7c4 : 68              >            pla         ;load status
d7c5 : 48              >            pha
                       >            cmp_flag fnz
d7c6 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d7c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7ca : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d7cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d7cd : 48              >            pha         ;use stack to load status
d7ce : a901            >            lda #1     ;precharge accu
d7d0 : 28              >            plp
                        
d7d1 : 245b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
d7d3 : 08              >            php         ;save flags
d7d4 : c901            >            cmp #1     ;test result
                       >            trap_ne
d7d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7d8 : 68              >            pla         ;load status
d7d9 : 48              >            pha
                       >            cmp_flag fnv
d7da : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d7dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7de : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,$ff
                       >            load_flag $ff
d7df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d7e1 : 48              >            pha         ;use stack to load status
d7e2 : a9ff            >            lda #$ff     ;precharge accu
d7e4 : 28              >            plp
                        
d7e5 : 245e                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv
d7e7 : 08              >            php         ;save flags
d7e8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
d7ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7ec : 68              >            pla         ;load status
d7ed : 48              >            pha
                       >            cmp_flag ~fnv
d7ee : c93f            >            cmp #(~fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d7f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d7f2 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d7f3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d7f5 : 48              >            pha         ;use stack to load status
d7f6 : a901            >            lda #1     ;precharge accu
d7f8 : 28              >            plp
                        
d7f9 : 245d                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
d7fb : 08              >            php         ;save flags
d7fc : c901            >            cmp #1     ;test result
                       >            trap_ne
d7fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d800 : 68              >            pla         ;load status
d801 : 48              >            pha
                       >            cmp_flag ~fnz
d802 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d804 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d806 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d807 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d809 : 48              >            pha         ;use stack to load status
d80a : a901            >            lda #1     ;precharge accu
d80c : 28              >            plp
                        
d80d : 245c                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
d80f : 08              >            php         ;save flags
d810 : c901            >            cmp #1     ;test result
                       >            trap_ne
d812 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d814 : 68              >            pla         ;load status
d815 : 48              >            pha
                       >            cmp_flag ~fv
d816 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d818 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d81a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d81b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d81d : 48              >            pha         ;use stack to load status
d81e : a901            >            lda #1     ;precharge accu
d820 : 28              >            plp
                        
d821 : 245b                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
d823 : 08              >            php         ;save flags
d824 : c901            >            cmp #1     ;test result
                       >            trap_ne
d826 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d828 : 68              >            pla         ;load status
d829 : 48              >            pha
                       >            cmp_flag ~fz
d82a : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d82c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d82e : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,0
                       >            load_flag 0
d82f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d831 : 48              >            pha         ;use stack to load status
d832 : a9ff            >            lda #$ff     ;precharge accu
d834 : 28              >            plp
                        
d835 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz
d838 : 08              >            php         ;save flags
d839 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
d83b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d83d : 68              >            pla         ;load status
d83e : 48              >            pha
                       >            cmp_flag fz
d83f : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d841 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d843 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d844 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d846 : 48              >            pha         ;use stack to load status
d847 : a901            >            lda #1     ;precharge accu
d849 : 28              >            plp
                        
d84a : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
d84d : 08              >            php         ;save flags
d84e : c901            >            cmp #1     ;test result
                       >            trap_ne
d850 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d852 : 68              >            pla         ;load status
d853 : 48              >            pha
                       >            cmp_flag fv
d854 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d856 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d858 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d859 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d85b : 48              >            pha         ;use stack to load status
d85c : a901            >            lda #1     ;precharge accu
d85e : 28              >            plp
                        
d85f : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
d862 : 08              >            php         ;save flags
d863 : c901            >            cmp #1     ;test result
                       >            trap_ne
d865 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d867 : 68              >            pla         ;load status
d868 : 48              >            pha
                       >            cmp_flag fnz
d869 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d86b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d86d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
d86e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d870 : 48              >            pha         ;use stack to load status
d871 : a901            >            lda #1     ;precharge accu
d873 : 28              >            plp
                        
d874 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
d877 : 08              >            php         ;save flags
d878 : c901            >            cmp #1     ;test result
                       >            trap_ne
d87a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d87c : 68              >            pla         ;load status
d87d : 48              >            pha
                       >            cmp_flag fnv
d87e : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d880 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d882 : 28              >            plp         ;restore status
                        
                        
                                set_a $ff,$ff
                       >            load_flag $ff
d883 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d885 : 48              >            pha         ;use stack to load status
d886 : a9ff            >            lda #$ff     ;precharge accu
d888 : 28              >            plp
                        
d889 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv
d88c : 08              >            php         ;save flags
d88d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
d88f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d891 : 68              >            pla         ;load status
d892 : 48              >            pha
                       >            cmp_flag ~fnv
d893 : c93f            >            cmp #(~fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d895 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d897 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d898 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d89a : 48              >            pha         ;use stack to load status
d89b : a901            >            lda #1     ;precharge accu
d89d : 28              >            plp
                        
d89e : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
d8a1 : 08              >            php         ;save flags
d8a2 : c901            >            cmp #1     ;test result
                       >            trap_ne
d8a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8a6 : 68              >            pla         ;load status
d8a7 : 48              >            pha
                       >            cmp_flag ~fnz
d8a8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d8aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8ac : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d8ad : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d8af : 48              >            pha         ;use stack to load status
d8b0 : a901            >            lda #1     ;precharge accu
d8b2 : 28              >            plp
                        
d8b3 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
d8b6 : 08              >            php         ;save flags
d8b7 : c901            >            cmp #1     ;test result
                       >            trap_ne
d8b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8bb : 68              >            pla         ;load status
d8bc : 48              >            pha
                       >            cmp_flag ~fv
d8bd : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d8bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8c1 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
d8c2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d8c4 : 48              >            pha         ;use stack to load status
d8c5 : a901            >            lda #1     ;precharge accu
d8c7 : 28              >            plp
                        
d8c8 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
d8cb : 08              >            php         ;save flags
d8cc : c901            >            cmp #1     ;test result
                       >            trap_ne
d8ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8d0 : 68              >            pla         ;load status
d8d1 : 48              >            pha
                       >            cmp_flag ~fz
d8d2 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d8d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8d6 : 28              >            plp         ;restore status
                        
                                next_test
d8d7 : ad0002          >            lda test_case   ;previous test
d8da : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d8dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
d8de : a91a            >            lda #test_num   ;*** next tests' number
d8e0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPX - zp / abs / #
                                set_x $80,0
                       >            load_flag 0
d8e3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d8e5 : 48              >            pha         ;use stack to load status
d8e6 : a280            >            ldx #$80     ;precharge index x
d8e8 : 28              >            plp
                        
d8e9 : e45f                     cpx zp7f
                                tst_stat fc
d8eb : 08              >            php         ;save status
d8ec : 68              >            pla         ;use stack to retrieve status
d8ed : 48              >            pha
                       >            cmp_flag fc
d8ee : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d8f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8f2 : 28              >            plp         ;restore status
                        
d8f3 : ca                       dex
d8f4 : e45f                     cpx zp7f
                                tst_stat fzc
d8f6 : 08              >            php         ;save status
d8f7 : 68              >            pla         ;use stack to retrieve status
d8f8 : 48              >            pha
                       >            cmp_flag fzc
d8f9 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d8fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d8fd : 28              >            plp         ;restore status
                        
d8fe : ca                       dex
d8ff : e45f                     cpx zp7f
                                tst_x $7e,fn
d901 : 08              >            php         ;save flags
d902 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d904 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d906 : 68              >            pla         ;load status
d907 : 48              >            pha
                       >            cmp_flag fn
d908 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d90a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d90c : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
d90d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d90f : 48              >            pha         ;use stack to load status
d910 : a280            >            ldx #$80     ;precharge index x
d912 : 28              >            plp
                        
d913 : e45f                     cpx zp7f
                                tst_stat ~fnz
d915 : 08              >            php         ;save status
d916 : 68              >            pla         ;use stack to retrieve status
d917 : 48              >            pha
                       >            cmp_flag ~fnz
d918 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d91a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d91c : 28              >            plp         ;restore status
                        
d91d : ca                       dex
d91e : e45f                     cpx zp7f
                                tst_stat ~fn
d920 : 08              >            php         ;save status
d921 : 68              >            pla         ;use stack to retrieve status
d922 : 48              >            pha
                       >            cmp_flag ~fn
d923 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d925 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d927 : 28              >            plp         ;restore status
                        
d928 : ca                       dex
d929 : e45f                     cpx zp7f
                                tst_x $7e,~fzc
d92b : 08              >            php         ;save flags
d92c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d92e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d930 : 68              >            pla         ;load status
d931 : 48              >            pha
                       >            cmp_flag ~fzc
d932 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d934 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d936 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
d937 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d939 : 48              >            pha         ;use stack to load status
d93a : a280            >            ldx #$80     ;precharge index x
d93c : 28              >            plp
                        
d93d : ec1c02                   cpx abs7f
                                tst_stat fc
d940 : 08              >            php         ;save status
d941 : 68              >            pla         ;use stack to retrieve status
d942 : 48              >            pha
                       >            cmp_flag fc
d943 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d945 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d947 : 28              >            plp         ;restore status
                        
d948 : ca                       dex
d949 : ec1c02                   cpx abs7f
                                tst_stat fzc
d94c : 08              >            php         ;save status
d94d : 68              >            pla         ;use stack to retrieve status
d94e : 48              >            pha
                       >            cmp_flag fzc
d94f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d951 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d953 : 28              >            plp         ;restore status
                        
d954 : ca                       dex
d955 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
d958 : 08              >            php         ;save flags
d959 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d95b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d95d : 68              >            pla         ;load status
d95e : 48              >            pha
                       >            cmp_flag fn
d95f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d961 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d963 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
d964 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d966 : 48              >            pha         ;use stack to load status
d967 : a280            >            ldx #$80     ;precharge index x
d969 : 28              >            plp
                        
d96a : ec1c02                   cpx abs7f
                                tst_stat ~fnz
d96d : 08              >            php         ;save status
d96e : 68              >            pla         ;use stack to retrieve status
d96f : 48              >            pha
                       >            cmp_flag ~fnz
d970 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d972 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d974 : 28              >            plp         ;restore status
                        
d975 : ca                       dex
d976 : ec1c02                   cpx abs7f
                                tst_stat ~fn
d979 : 08              >            php         ;save status
d97a : 68              >            pla         ;use stack to retrieve status
d97b : 48              >            pha
                       >            cmp_flag ~fn
d97c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d97e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d980 : 28              >            plp         ;restore status
                        
d981 : ca                       dex
d982 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
d985 : 08              >            php         ;save flags
d986 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d988 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d98a : 68              >            pla         ;load status
d98b : 48              >            pha
                       >            cmp_flag ~fzc
d98c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d98e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d990 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
d991 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d993 : 48              >            pha         ;use stack to load status
d994 : a280            >            ldx #$80     ;precharge index x
d996 : 28              >            plp
                        
d997 : e07f                     cpx #$7f
                                tst_stat fc
d999 : 08              >            php         ;save status
d99a : 68              >            pla         ;use stack to retrieve status
d99b : 48              >            pha
                       >            cmp_flag fc
d99c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d99e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9a0 : 28              >            plp         ;restore status
                        
d9a1 : ca                       dex
d9a2 : e07f                     cpx #$7f
                                tst_stat fzc
d9a4 : 08              >            php         ;save status
d9a5 : 68              >            pla         ;use stack to retrieve status
d9a6 : 48              >            pha
                       >            cmp_flag fzc
d9a7 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9ab : 28              >            plp         ;restore status
                        
d9ac : ca                       dex
d9ad : e07f                     cpx #$7f
                                tst_x $7e,fn
d9af : 08              >            php         ;save flags
d9b0 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d9b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9b4 : 68              >            pla         ;load status
d9b5 : 48              >            pha
                       >            cmp_flag fn
d9b6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9ba : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
d9bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
d9bd : 48              >            pha         ;use stack to load status
d9be : a280            >            ldx #$80     ;precharge index x
d9c0 : 28              >            plp
                        
d9c1 : e07f                     cpx #$7f
                                tst_stat ~fnz
d9c3 : 08              >            php         ;save status
d9c4 : 68              >            pla         ;use stack to retrieve status
d9c5 : 48              >            pha
                       >            cmp_flag ~fnz
d9c6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9ca : 28              >            plp         ;restore status
                        
d9cb : ca                       dex
d9cc : e07f                     cpx #$7f
                                tst_stat ~fn
d9ce : 08              >            php         ;save status
d9cf : 68              >            pla         ;use stack to retrieve status
d9d0 : 48              >            pha
                       >            cmp_flag ~fn
d9d1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9d5 : 28              >            plp         ;restore status
                        
d9d6 : ca                       dex
d9d7 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
d9d9 : 08              >            php         ;save flags
d9da : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
d9dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9de : 68              >            pla         ;load status
d9df : 48              >            pha
                       >            cmp_flag ~fzc
d9e0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
d9e4 : 28              >            plp         ;restore status
                        
                                next_test
d9e5 : ad0002          >            lda test_case   ;previous test
d9e8 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
d9ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
d9ec : a91b            >            lda #test_num   ;*** next tests' number
d9ee : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #
                                set_y $80,0
                       >            load_flag 0
d9f1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
d9f3 : 48              >            pha         ;use stack to load status
d9f4 : a080            >            ldy #$80     ;precharge index y
d9f6 : 28              >            plp
                        
d9f7 : c45f                     cpy zp7f
                                tst_stat fc
d9f9 : 08              >            php         ;save status
d9fa : 68              >            pla         ;use stack to retrieve status
d9fb : 48              >            pha
                       >            cmp_flag fc
d9fc : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
d9fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da00 : 28              >            plp         ;restore status
                        
da01 : 88                       dey
da02 : c45f                     cpy zp7f
                                tst_stat fzc
da04 : 08              >            php         ;save status
da05 : 68              >            pla         ;use stack to retrieve status
da06 : 48              >            pha
                       >            cmp_flag fzc
da07 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da0b : 28              >            plp         ;restore status
                        
da0c : 88                       dey
da0d : c45f                     cpy zp7f
                                tst_y $7e,fn
da0f : 08              >            php         ;save flags
da10 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
da12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da14 : 68              >            pla         ;load status
da15 : 48              >            pha
                       >            cmp_flag fn
da16 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da1a : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
da1b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
da1d : 48              >            pha         ;use stack to load status
da1e : a080            >            ldy #$80     ;precharge index y
da20 : 28              >            plp
                        
da21 : c45f                     cpy zp7f
                                tst_stat ~fnz
da23 : 08              >            php         ;save status
da24 : 68              >            pla         ;use stack to retrieve status
da25 : 48              >            pha
                       >            cmp_flag ~fnz
da26 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da2a : 28              >            plp         ;restore status
                        
da2b : 88                       dey
da2c : c45f                     cpy zp7f
                                tst_stat ~fn
da2e : 08              >            php         ;save status
da2f : 68              >            pla         ;use stack to retrieve status
da30 : 48              >            pha
                       >            cmp_flag ~fn
da31 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da35 : 28              >            plp         ;restore status
                        
da36 : 88                       dey
da37 : c45f                     cpy zp7f
                                tst_y $7e,~fzc
da39 : 08              >            php         ;save flags
da3a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
da3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da3e : 68              >            pla         ;load status
da3f : 48              >            pha
                       >            cmp_flag ~fzc
da40 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da44 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
da45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
da47 : 48              >            pha         ;use stack to load status
da48 : a080            >            ldy #$80     ;precharge index y
da4a : 28              >            plp
                        
da4b : cc1c02                   cpy abs7f
                                tst_stat fc
da4e : 08              >            php         ;save status
da4f : 68              >            pla         ;use stack to retrieve status
da50 : 48              >            pha
                       >            cmp_flag fc
da51 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da55 : 28              >            plp         ;restore status
                        
da56 : 88                       dey
da57 : cc1c02                   cpy abs7f
                                tst_stat fzc
da5a : 08              >            php         ;save status
da5b : 68              >            pla         ;use stack to retrieve status
da5c : 48              >            pha
                       >            cmp_flag fzc
da5d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da61 : 28              >            plp         ;restore status
                        
da62 : 88                       dey
da63 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
da66 : 08              >            php         ;save flags
da67 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
da69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da6b : 68              >            pla         ;load status
da6c : 48              >            pha
                       >            cmp_flag fn
da6d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da71 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
da72 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
da74 : 48              >            pha         ;use stack to load status
da75 : a080            >            ldy #$80     ;precharge index y
da77 : 28              >            plp
                        
da78 : cc1c02                   cpy abs7f
                                tst_stat ~fnz
da7b : 08              >            php         ;save status
da7c : 68              >            pla         ;use stack to retrieve status
da7d : 48              >            pha
                       >            cmp_flag ~fnz
da7e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da82 : 28              >            plp         ;restore status
                        
da83 : 88                       dey
da84 : cc1c02                   cpy abs7f
                                tst_stat ~fn
da87 : 08              >            php         ;save status
da88 : 68              >            pla         ;use stack to retrieve status
da89 : 48              >            pha
                       >            cmp_flag ~fn
da8a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da8e : 28              >            plp         ;restore status
                        
da8f : 88                       dey
da90 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
da93 : 08              >            php         ;save flags
da94 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
da96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da98 : 68              >            pla         ;load status
da99 : 48              >            pha
                       >            cmp_flag ~fzc
da9a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
da9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
da9e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
da9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
daa1 : 48              >            pha         ;use stack to load status
daa2 : a080            >            ldy #$80     ;precharge index y
daa4 : 28              >            plp
                        
daa5 : c07f                     cpy #$7f
                                tst_stat fc
daa7 : 08              >            php         ;save status
daa8 : 68              >            pla         ;use stack to retrieve status
daa9 : 48              >            pha
                       >            cmp_flag fc
daaa : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
daac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
daae : 28              >            plp         ;restore status
                        
daaf : 88                       dey
dab0 : c07f                     cpy #$7f
                                tst_stat fzc
dab2 : 08              >            php         ;save status
dab3 : 68              >            pla         ;use stack to retrieve status
dab4 : 48              >            pha
                       >            cmp_flag fzc
dab5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dab7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dab9 : 28              >            plp         ;restore status
                        
daba : 88                       dey
dabb : c07f                     cpy #$7f
                                tst_y $7e,fn
dabd : 08              >            php         ;save flags
dabe : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
dac0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dac2 : 68              >            pla         ;load status
dac3 : 48              >            pha
                       >            cmp_flag fn
dac4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dac6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dac8 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
dac9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dacb : 48              >            pha         ;use stack to load status
dacc : a080            >            ldy #$80     ;precharge index y
dace : 28              >            plp
                        
dacf : c07f                     cpy #$7f
                                tst_stat ~fnz
dad1 : 08              >            php         ;save status
dad2 : 68              >            pla         ;use stack to retrieve status
dad3 : 48              >            pha
                       >            cmp_flag ~fnz
dad4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dad6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dad8 : 28              >            plp         ;restore status
                        
dad9 : 88                       dey
dada : c07f                     cpy #$7f
                                tst_stat ~fn
dadc : 08              >            php         ;save status
dadd : 68              >            pla         ;use stack to retrieve status
dade : 48              >            pha
                       >            cmp_flag ~fn
dadf : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dae1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dae3 : 28              >            plp         ;restore status
                        
dae4 : 88                       dey
dae5 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
dae7 : 08              >            php         ;save flags
dae8 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
daea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
daec : 68              >            pla         ;load status
daed : 48              >            pha
                       >            cmp_flag ~fzc
daee : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
daf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
daf2 : 28              >            plp         ;restore status
                        
                                next_test
daf3 : ad0002          >            lda test_case   ;previous test
daf6 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
daf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
dafa : a91c            >            lda #test_num   ;*** next tests' number
dafc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #
                                set_a $80,0
                       >            load_flag 0
daff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
db01 : 48              >            pha         ;use stack to load status
db02 : a980            >            lda #$80     ;precharge accu
db04 : 28              >            plp
                        
db05 : c55f                     cmp zp7f
                                tst_a $80,fc
db07 : 08              >            php         ;save flags
db08 : c980            >            cmp #$80     ;test result
                       >            trap_ne
db0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db0c : 68              >            pla         ;load status
db0d : 48              >            pha
                       >            cmp_flag fc
db0e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db12 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
db13 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
db15 : 48              >            pha         ;use stack to load status
db16 : a97f            >            lda #$7f     ;precharge accu
db18 : 28              >            plp
                        
db19 : c55f                     cmp zp7f
                                tst_a $7f,fzc
db1b : 08              >            php         ;save flags
db1c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
db1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db20 : 68              >            pla         ;load status
db21 : 48              >            pha
                       >            cmp_flag fzc
db22 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db26 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
db27 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
db29 : 48              >            pha         ;use stack to load status
db2a : a97e            >            lda #$7e     ;precharge accu
db2c : 28              >            plp
                        
db2d : c55f                     cmp zp7f
                                tst_a $7e,fn
db2f : 08              >            php         ;save flags
db30 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
db32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db34 : 68              >            pla         ;load status
db35 : 48              >            pha
                       >            cmp_flag fn
db36 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db3a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
db3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
db3d : 48              >            pha         ;use stack to load status
db3e : a980            >            lda #$80     ;precharge accu
db40 : 28              >            plp
                        
db41 : c55f                     cmp zp7f
                                tst_a $80,~fnz
db43 : 08              >            php         ;save flags
db44 : c980            >            cmp #$80     ;test result
                       >            trap_ne
db46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db48 : 68              >            pla         ;load status
db49 : 48              >            pha
                       >            cmp_flag ~fnz
db4a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db4e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
db4f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
db51 : 48              >            pha         ;use stack to load status
db52 : a97f            >            lda #$7f     ;precharge accu
db54 : 28              >            plp
                        
db55 : c55f                     cmp zp7f
                                tst_a $7f,~fn
db57 : 08              >            php         ;save flags
db58 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
db5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db5c : 68              >            pla         ;load status
db5d : 48              >            pha
                       >            cmp_flag ~fn
db5e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db62 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
db63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
db65 : 48              >            pha         ;use stack to load status
db66 : a97e            >            lda #$7e     ;precharge accu
db68 : 28              >            plp
                        
db69 : c55f                     cmp zp7f
                                tst_a $7e,~fzc
db6b : 08              >            php         ;save flags
db6c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
db6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db70 : 68              >            pla         ;load status
db71 : 48              >            pha
                       >            cmp_flag ~fzc
db72 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db76 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
db77 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
db79 : 48              >            pha         ;use stack to load status
db7a : a980            >            lda #$80     ;precharge accu
db7c : 28              >            plp
                        
db7d : cd1c02                   cmp abs7f
                                tst_a $80,fc
db80 : 08              >            php         ;save flags
db81 : c980            >            cmp #$80     ;test result
                       >            trap_ne
db83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db85 : 68              >            pla         ;load status
db86 : 48              >            pha
                       >            cmp_flag fc
db87 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db8b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
db8c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
db8e : 48              >            pha         ;use stack to load status
db8f : a97f            >            lda #$7f     ;precharge accu
db91 : 28              >            plp
                        
db92 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
db95 : 08              >            php         ;save flags
db96 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
db98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
db9a : 68              >            pla         ;load status
db9b : 48              >            pha
                       >            cmp_flag fzc
db9c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
db9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dba0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
dba1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dba3 : 48              >            pha         ;use stack to load status
dba4 : a97e            >            lda #$7e     ;precharge accu
dba6 : 28              >            plp
                        
dba7 : cd1c02                   cmp abs7f
                                tst_a $7e,fn
dbaa : 08              >            php         ;save flags
dbab : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dbad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbaf : 68              >            pla         ;load status
dbb0 : 48              >            pha
                       >            cmp_flag fn
dbb1 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dbb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbb5 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
dbb6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dbb8 : 48              >            pha         ;use stack to load status
dbb9 : a980            >            lda #$80     ;precharge accu
dbbb : 28              >            plp
                        
dbbc : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
dbbf : 08              >            php         ;save flags
dbc0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dbc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbc4 : 68              >            pla         ;load status
dbc5 : 48              >            pha
                       >            cmp_flag ~fnz
dbc6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dbc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbca : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
dbcb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dbcd : 48              >            pha         ;use stack to load status
dbce : a97f            >            lda #$7f     ;precharge accu
dbd0 : 28              >            plp
                        
dbd1 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
dbd4 : 08              >            php         ;save flags
dbd5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dbd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbd9 : 68              >            pla         ;load status
dbda : 48              >            pha
                       >            cmp_flag ~fn
dbdb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dbdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbdf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
dbe0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dbe2 : 48              >            pha         ;use stack to load status
dbe3 : a97e            >            lda #$7e     ;precharge accu
dbe5 : 28              >            plp
                        
dbe6 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
dbe9 : 08              >            php         ;save flags
dbea : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dbec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbee : 68              >            pla         ;load status
dbef : 48              >            pha
                       >            cmp_flag ~fzc
dbf0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dbf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dbf4 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
dbf5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dbf7 : 48              >            pha         ;use stack to load status
dbf8 : a980            >            lda #$80     ;precharge accu
dbfa : 28              >            plp
                        
dbfb : c97f                     cmp #$7f
                                tst_a $80,fc
dbfd : 08              >            php         ;save flags
dbfe : c980            >            cmp #$80     ;test result
                       >            trap_ne
dc00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc02 : 68              >            pla         ;load status
dc03 : 48              >            pha
                       >            cmp_flag fc
dc04 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc08 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
dc09 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dc0b : 48              >            pha         ;use stack to load status
dc0c : a97f            >            lda #$7f     ;precharge accu
dc0e : 28              >            plp
                        
dc0f : c97f                     cmp #$7f
                                tst_a $7f,fzc
dc11 : 08              >            php         ;save flags
dc12 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dc14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc16 : 68              >            pla         ;load status
dc17 : 48              >            pha
                       >            cmp_flag fzc
dc18 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc1c : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
dc1d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dc1f : 48              >            pha         ;use stack to load status
dc20 : a97e            >            lda #$7e     ;precharge accu
dc22 : 28              >            plp
                        
dc23 : c97f                     cmp #$7f
                                tst_a $7e,fn
dc25 : 08              >            php         ;save flags
dc26 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dc28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc2a : 68              >            pla         ;load status
dc2b : 48              >            pha
                       >            cmp_flag fn
dc2c : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc30 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
dc31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dc33 : 48              >            pha         ;use stack to load status
dc34 : a980            >            lda #$80     ;precharge accu
dc36 : 28              >            plp
                        
dc37 : c97f                     cmp #$7f
                                tst_a $80,~fnz
dc39 : 08              >            php         ;save flags
dc3a : c980            >            cmp #$80     ;test result
                       >            trap_ne
dc3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc3e : 68              >            pla         ;load status
dc3f : 48              >            pha
                       >            cmp_flag ~fnz
dc40 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc44 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
dc45 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dc47 : 48              >            pha         ;use stack to load status
dc48 : a97f            >            lda #$7f     ;precharge accu
dc4a : 28              >            plp
                        
dc4b : c97f                     cmp #$7f
                                tst_a $7f,~fn
dc4d : 08              >            php         ;save flags
dc4e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dc50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc52 : 68              >            pla         ;load status
dc53 : 48              >            pha
                       >            cmp_flag ~fn
dc54 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc58 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
dc59 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dc5b : 48              >            pha         ;use stack to load status
dc5c : a97e            >            lda #$7e     ;precharge accu
dc5e : 28              >            plp
                        
dc5f : c97f                     cmp #$7f
                                tst_a $7e,~fzc
dc61 : 08              >            php         ;save flags
dc62 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dc64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc66 : 68              >            pla         ;load status
dc67 : 48              >            pha
                       >            cmp_flag ~fzc
dc68 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc6c : 28              >            plp         ;restore status
                        
                        
dc6d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
dc6f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dc71 : 48              >            pha         ;use stack to load status
dc72 : a980            >            lda #$80     ;precharge accu
dc74 : 28              >            plp
                        
dc75 : d55b                     cmp zp1,x
                                tst_a $80,fc
dc77 : 08              >            php         ;save flags
dc78 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dc7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc7c : 68              >            pla         ;load status
dc7d : 48              >            pha
                       >            cmp_flag fc
dc7e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc82 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
dc83 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dc85 : 48              >            pha         ;use stack to load status
dc86 : a97f            >            lda #$7f     ;precharge accu
dc88 : 28              >            plp
                        
dc89 : d55b                     cmp zp1,x
                                tst_a $7f,fzc
dc8b : 08              >            php         ;save flags
dc8c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dc8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc90 : 68              >            pla         ;load status
dc91 : 48              >            pha
                       >            cmp_flag fzc
dc92 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dc94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dc96 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
dc97 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dc99 : 48              >            pha         ;use stack to load status
dc9a : a97e            >            lda #$7e     ;precharge accu
dc9c : 28              >            plp
                        
dc9d : d55b                     cmp zp1,x
                                tst_a $7e,fn
dc9f : 08              >            php         ;save flags
dca0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dca2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dca4 : 68              >            pla         ;load status
dca5 : 48              >            pha
                       >            cmp_flag fn
dca6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dca8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcaa : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
dcab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dcad : 48              >            pha         ;use stack to load status
dcae : a980            >            lda #$80     ;precharge accu
dcb0 : 28              >            plp
                        
dcb1 : d55b                     cmp zp1,x
                                tst_a $80,~fnz
dcb3 : 08              >            php         ;save flags
dcb4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dcb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcb8 : 68              >            pla         ;load status
dcb9 : 48              >            pha
                       >            cmp_flag ~fnz
dcba : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dcbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcbe : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
dcbf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dcc1 : 48              >            pha         ;use stack to load status
dcc2 : a97f            >            lda #$7f     ;precharge accu
dcc4 : 28              >            plp
                        
dcc5 : d55b                     cmp zp1,x
                                tst_a $7f,~fn
dcc7 : 08              >            php         ;save flags
dcc8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dcca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dccc : 68              >            pla         ;load status
dccd : 48              >            pha
                       >            cmp_flag ~fn
dcce : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dcd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcd2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
dcd3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dcd5 : 48              >            pha         ;use stack to load status
dcd6 : a97e            >            lda #$7e     ;precharge accu
dcd8 : 28              >            plp
                        
dcd9 : d55b                     cmp zp1,x
                                tst_a $7e,~fzc
dcdb : 08              >            php         ;save flags
dcdc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dcde : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dce0 : 68              >            pla         ;load status
dce1 : 48              >            pha
                       >            cmp_flag ~fzc
dce2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dce4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dce6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
dce7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dce9 : 48              >            pha         ;use stack to load status
dcea : a980            >            lda #$80     ;precharge accu
dcec : 28              >            plp
                        
dced : dd1802                   cmp abs1,x
                                tst_a $80,fc
dcf0 : 08              >            php         ;save flags
dcf1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dcf3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcf5 : 68              >            pla         ;load status
dcf6 : 48              >            pha
                       >            cmp_flag fc
dcf7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dcf9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dcfb : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
dcfc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dcfe : 48              >            pha         ;use stack to load status
dcff : a97f            >            lda #$7f     ;precharge accu
dd01 : 28              >            plp
                        
dd02 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
dd05 : 08              >            php         ;save flags
dd06 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dd08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd0a : 68              >            pla         ;load status
dd0b : 48              >            pha
                       >            cmp_flag fzc
dd0c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd10 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
dd11 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dd13 : 48              >            pha         ;use stack to load status
dd14 : a97e            >            lda #$7e     ;precharge accu
dd16 : 28              >            plp
                        
dd17 : dd1802                   cmp abs1,x
                                tst_a $7e,fn
dd1a : 08              >            php         ;save flags
dd1b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dd1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd1f : 68              >            pla         ;load status
dd20 : 48              >            pha
                       >            cmp_flag fn
dd21 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd25 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
dd26 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dd28 : 48              >            pha         ;use stack to load status
dd29 : a980            >            lda #$80     ;precharge accu
dd2b : 28              >            plp
                        
dd2c : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
dd2f : 08              >            php         ;save flags
dd30 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dd32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd34 : 68              >            pla         ;load status
dd35 : 48              >            pha
                       >            cmp_flag ~fnz
dd36 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd3a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
dd3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dd3d : 48              >            pha         ;use stack to load status
dd3e : a97f            >            lda #$7f     ;precharge accu
dd40 : 28              >            plp
                        
dd41 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
dd44 : 08              >            php         ;save flags
dd45 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dd47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd49 : 68              >            pla         ;load status
dd4a : 48              >            pha
                       >            cmp_flag ~fn
dd4b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd4f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
dd50 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dd52 : 48              >            pha         ;use stack to load status
dd53 : a97e            >            lda #$7e     ;precharge accu
dd55 : 28              >            plp
                        
dd56 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
dd59 : 08              >            php         ;save flags
dd5a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dd5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd5e : 68              >            pla         ;load status
dd5f : 48              >            pha
                       >            cmp_flag ~fzc
dd60 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd64 : 28              >            plp         ;restore status
                        
                        
dd65 : a004                     ldy #4          ;with indexing by Y
dd67 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
dd69 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dd6b : 48              >            pha         ;use stack to load status
dd6c : a980            >            lda #$80     ;precharge accu
dd6e : 28              >            plp
                        
dd6f : d91802                   cmp abs1,y
                                tst_a $80,fc
dd72 : 08              >            php         ;save flags
dd73 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dd75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd77 : 68              >            pla         ;load status
dd78 : 48              >            pha
                       >            cmp_flag fc
dd79 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd7d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
dd7e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dd80 : 48              >            pha         ;use stack to load status
dd81 : a97f            >            lda #$7f     ;precharge accu
dd83 : 28              >            plp
                        
dd84 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
dd87 : 08              >            php         ;save flags
dd88 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
dd8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd8c : 68              >            pla         ;load status
dd8d : 48              >            pha
                       >            cmp_flag fzc
dd8e : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dd90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dd92 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
dd93 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dd95 : 48              >            pha         ;use stack to load status
dd96 : a97e            >            lda #$7e     ;precharge accu
dd98 : 28              >            plp
                        
dd99 : d91802                   cmp abs1,y
                                tst_a $7e,fn
dd9c : 08              >            php         ;save flags
dd9d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dd9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dda1 : 68              >            pla         ;load status
dda2 : 48              >            pha
                       >            cmp_flag fn
dda3 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dda5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dda7 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
dda8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ddaa : 48              >            pha         ;use stack to load status
ddab : a980            >            lda #$80     ;precharge accu
ddad : 28              >            plp
                        
ddae : d91802                   cmp abs1,y
                                tst_a $80,~fnz
ddb1 : 08              >            php         ;save flags
ddb2 : c980            >            cmp #$80     ;test result
                       >            trap_ne
ddb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddb6 : 68              >            pla         ;load status
ddb7 : 48              >            pha
                       >            cmp_flag ~fnz
ddb8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
ddba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddbc : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
ddbd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ddbf : 48              >            pha         ;use stack to load status
ddc0 : a97f            >            lda #$7f     ;precharge accu
ddc2 : 28              >            plp
                        
ddc3 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
ddc6 : 08              >            php         ;save flags
ddc7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
ddc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddcb : 68              >            pla         ;load status
ddcc : 48              >            pha
                       >            cmp_flag ~fn
ddcd : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
ddcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddd1 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
ddd2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ddd4 : 48              >            pha         ;use stack to load status
ddd5 : a97e            >            lda #$7e     ;precharge accu
ddd7 : 28              >            plp
                        
ddd8 : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
dddb : 08              >            php         ;save flags
dddc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
ddde : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dde0 : 68              >            pla         ;load status
dde1 : 48              >            pha
                       >            cmp_flag ~fzc
dde2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dde4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dde6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
dde7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dde9 : 48              >            pha         ;use stack to load status
ddea : a980            >            lda #$80     ;precharge accu
ddec : 28              >            plp
                        
dded : c16c                     cmp (ind1,x)
                                tst_a $80,fc
ddef : 08              >            php         ;save flags
ddf0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
ddf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddf4 : 68              >            pla         ;load status
ddf5 : 48              >            pha
                       >            cmp_flag fc
ddf6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
ddf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ddfa : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
ddfb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ddfd : 48              >            pha         ;use stack to load status
ddfe : a97f            >            lda #$7f     ;precharge accu
de00 : 28              >            plp
                        
de01 : c16c                     cmp (ind1,x)
                                tst_a $7f,fzc
de03 : 08              >            php         ;save flags
de04 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
de06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de08 : 68              >            pla         ;load status
de09 : 48              >            pha
                       >            cmp_flag fzc
de0a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de0e : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
de0f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
de11 : 48              >            pha         ;use stack to load status
de12 : a97e            >            lda #$7e     ;precharge accu
de14 : 28              >            plp
                        
de15 : c16c                     cmp (ind1,x)
                                tst_a $7e,fn
de17 : 08              >            php         ;save flags
de18 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
de1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de1c : 68              >            pla         ;load status
de1d : 48              >            pha
                       >            cmp_flag fn
de1e : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de22 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
de23 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
de25 : 48              >            pha         ;use stack to load status
de26 : a980            >            lda #$80     ;precharge accu
de28 : 28              >            plp
                        
de29 : c16c                     cmp (ind1,x)
                                tst_a $80,~fnz
de2b : 08              >            php         ;save flags
de2c : c980            >            cmp #$80     ;test result
                       >            trap_ne
de2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de30 : 68              >            pla         ;load status
de31 : 48              >            pha
                       >            cmp_flag ~fnz
de32 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de36 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
de37 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
de39 : 48              >            pha         ;use stack to load status
de3a : a97f            >            lda #$7f     ;precharge accu
de3c : 28              >            plp
                        
de3d : c16c                     cmp (ind1,x)
                                tst_a $7f,~fn
de3f : 08              >            php         ;save flags
de40 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
de42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de44 : 68              >            pla         ;load status
de45 : 48              >            pha
                       >            cmp_flag ~fn
de46 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de4a : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
de4b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
de4d : 48              >            pha         ;use stack to load status
de4e : a97e            >            lda #$7e     ;precharge accu
de50 : 28              >            plp
                        
de51 : c16c                     cmp (ind1,x)
                                tst_a $7e,~fzc
de53 : 08              >            php         ;save flags
de54 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
de56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de58 : 68              >            pla         ;load status
de59 : 48              >            pha
                       >            cmp_flag ~fzc
de5a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de5e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
de5f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
de61 : 48              >            pha         ;use stack to load status
de62 : a980            >            lda #$80     ;precharge accu
de64 : 28              >            plp
                        
de65 : d16c                     cmp (ind1),y
                                tst_a $80,fc
de67 : 08              >            php         ;save flags
de68 : c980            >            cmp #$80     ;test result
                       >            trap_ne
de6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de6c : 68              >            pla         ;load status
de6d : 48              >            pha
                       >            cmp_flag fc
de6e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de72 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
de73 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
de75 : 48              >            pha         ;use stack to load status
de76 : a97f            >            lda #$7f     ;precharge accu
de78 : 28              >            plp
                        
de79 : d16c                     cmp (ind1),y
                                tst_a $7f,fzc
de7b : 08              >            php         ;save flags
de7c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
de7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de80 : 68              >            pla         ;load status
de81 : 48              >            pha
                       >            cmp_flag fzc
de82 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de86 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
de87 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
de89 : 48              >            pha         ;use stack to load status
de8a : a97e            >            lda #$7e     ;precharge accu
de8c : 28              >            plp
                        
de8d : d16c                     cmp (ind1),y
                                tst_a $7e,fn
de8f : 08              >            php         ;save flags
de90 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
de92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de94 : 68              >            pla         ;load status
de95 : 48              >            pha
                       >            cmp_flag fn
de96 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
de98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
de9a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
de9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
de9d : 48              >            pha         ;use stack to load status
de9e : a980            >            lda #$80     ;precharge accu
dea0 : 28              >            plp
                        
dea1 : d16c                     cmp (ind1),y
                                tst_a $80,~fnz
dea3 : 08              >            php         ;save flags
dea4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
dea6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dea8 : 68              >            pla         ;load status
dea9 : 48              >            pha
                       >            cmp_flag ~fnz
deaa : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
deac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
deae : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
deaf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
deb1 : 48              >            pha         ;use stack to load status
deb2 : a97f            >            lda #$7f     ;precharge accu
deb4 : 28              >            plp
                        
deb5 : d16c                     cmp (ind1),y
                                tst_a $7f,~fn
deb7 : 08              >            php         ;save flags
deb8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
deba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
debc : 68              >            pla         ;load status
debd : 48              >            pha
                       >            cmp_flag ~fn
debe : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
dec0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dec2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
dec3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
dec5 : 48              >            pha         ;use stack to load status
dec6 : a97e            >            lda #$7e     ;precharge accu
dec8 : 28              >            plp
                        
dec9 : d16c                     cmp (ind1),y
                                tst_a $7e,~fzc
decb : 08              >            php         ;save flags
decc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
dece : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ded0 : 68              >            pla         ;load status
ded1 : 48              >            pha
                       >            cmp_flag ~fzc
ded2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
ded4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ded6 : 28              >            plp         ;restore status
                        
                                next_test
ded7 : ad0002          >            lda test_case   ;previous test
deda : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
dedc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
dede : a91d            >            lda #test_num   ;*** next tests' number
dee0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
dee3 : a205                     ldx #5
dee5 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
dee5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dee7 : 48              >            pha         ;use stack to load status
dee8 : b559            >            lda zps,x    ;precharge accu
deea : 28              >            plp
                        
deeb : 0a                       asl a
                                tst_ax rASL,fASL,0
deec : 08              >            php         ;save flags
deed : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
def0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
def2 : 68              >            pla         ;load status
                       >            eor_flag 0
def3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
def5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
def8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
defa : ca                       dex
defb : 10e8                     bpl tasl
defd : a205                     ldx #5
deff :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
deff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
df01 : 48              >            pha         ;use stack to load status
df02 : b559            >            lda zps,x    ;precharge accu
df04 : 28              >            plp
                        
df05 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
df06 : 08              >            php         ;save flags
df07 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
df0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df0c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
df0d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
df0f : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
df12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df14 : ca                       dex
df15 : 10e8                     bpl tasl1
                        
df17 : a205                     ldx #5
df19 :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
df19 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
df1b : 48              >            pha         ;use stack to load status
df1c : b559            >            lda zps,x    ;precharge accu
df1e : 28              >            plp
                        
df1f : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
df20 : 08              >            php         ;save flags
df21 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
df24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df26 : 68              >            pla         ;load status
                       >            eor_flag 0
df27 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
df29 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
df2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df2e : ca                       dex
df2f : 10e8                     bpl tlsr
df31 : a205                     ldx #5
df33 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
df33 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
df35 : 48              >            pha         ;use stack to load status
df36 : b559            >            lda zps,x    ;precharge accu
df38 : 28              >            plp
                        
df39 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
df3a : 08              >            php         ;save flags
df3b : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
df3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df40 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
df41 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
df43 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
df46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df48 : ca                       dex
df49 : 10e8                     bpl tlsr1
                        
df4b : a205                     ldx #5
df4d :                  trol
                                set_ax zps,0
                       >            load_flag 0
df4d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
df4f : 48              >            pha         ;use stack to load status
df50 : b559            >            lda zps,x    ;precharge accu
df52 : 28              >            plp
                        
df53 : 2a                       rol a
                                tst_ax rROL,fROL,0
df54 : 08              >            php         ;save flags
df55 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
df58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df5a : 68              >            pla         ;load status
                       >            eor_flag 0
df5b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
df5d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
df60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df62 : ca                       dex
df63 : 10e8                     bpl trol
df65 : a205                     ldx #5
df67 :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
df67 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
df69 : 48              >            pha         ;use stack to load status
df6a : b559            >            lda zps,x    ;precharge accu
df6c : 28              >            plp
                        
df6d : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
df6e : 08              >            php         ;save flags
df6f : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
df72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df74 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
df75 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
df77 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
df7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df7c : ca                       dex
df7d : 10e8                     bpl trol1
                        
df7f : a205                     ldx #5
df81 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
df81 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
df83 : 48              >            pha         ;use stack to load status
df84 : b559            >            lda zps,x    ;precharge accu
df86 : 28              >            plp
                        
df87 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
df88 : 08              >            php         ;save flags
df89 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
df8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
df8e : 68              >            pla         ;load status
                       >            eor_flag 0
df8f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
df91 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
df94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
df96 : ca                       dex
df97 : 10e8                     bpl trolc
df99 : a205                     ldx #5
df9b :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
df9b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
df9d : 48              >            pha         ;use stack to load status
df9e : b559            >            lda zps,x    ;precharge accu
dfa0 : 28              >            plp
                        
dfa1 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
dfa2 : 08              >            php         ;save flags
dfa3 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
dfa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dfa8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
dfa9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
dfab : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
dfae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
dfb0 : ca                       dex
dfb1 : 10e8                     bpl trolc1
                        
dfb3 : a205                     ldx #5
dfb5 :                  tror
                                set_ax zps,0
                       >            load_flag 0
dfb5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
dfb7 : 48              >            pha         ;use stack to load status
dfb8 : b559            >            lda zps,x    ;precharge accu
dfba : 28              >            plp
                        
dfbb : 6a                       ror a
                                tst_ax rROR,fROR,0
dfbc : 08              >            php         ;save flags
dfbd : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
dfc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dfc2 : 68              >            pla         ;load status
                       >            eor_flag 0
dfc3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
dfc5 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
dfc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
dfca : ca                       dex
dfcb : 10e8                     bpl tror
dfcd : a205                     ldx #5
dfcf :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
dfcf : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
dfd1 : 48              >            pha         ;use stack to load status
dfd2 : b559            >            lda zps,x    ;precharge accu
dfd4 : 28              >            plp
                        
dfd5 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
dfd6 : 08              >            php         ;save flags
dfd7 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
dfda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dfdc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
dfdd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
dfdf : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
dfe2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
dfe4 : ca                       dex
dfe5 : 10e8                     bpl tror1
                        
dfe7 : a205                     ldx #5
dfe9 :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
dfe9 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
dfeb : 48              >            pha         ;use stack to load status
dfec : b559            >            lda zps,x    ;precharge accu
dfee : 28              >            plp
                        
dfef : 6a                       ror a
                                tst_ax rRORc,fRORc,0
dff0 : 08              >            php         ;save flags
dff1 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
dff4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
dff6 : 68              >            pla         ;load status
                       >            eor_flag 0
dff7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
dff9 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
dffc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
dffe : ca                       dex
dfff : 10e8                     bpl trorc
e001 : a205                     ldx #5
e003 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
e003 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e005 : 48              >            pha         ;use stack to load status
e006 : b559            >            lda zps,x    ;precharge accu
e008 : 28              >            plp
                        
e009 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
e00a : 08              >            php         ;save flags
e00b : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e00e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e010 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e011 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e013 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
e016 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e018 : ca                       dex
e019 : 10e8                     bpl trorc1
                                next_test
e01b : ad0002          >            lda test_case   ;previous test
e01e : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e020 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
e022 : a91e            >            lda #test_num   ;*** next tests' number
e024 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
e027 : a205                     ldx #5
e029 :                  tasl2
                                set_z zps,0
                       >            load_flag 0
e029 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e02b : 48              >            pha         ;use stack to load status
e02c : b559            >            lda zps,x    ;load to zeropage
e02e : 8552            >            sta zpt
e030 : 28              >            plp
                        
e031 : 0652                     asl zpt
                                tst_z rASL,fASL,0
e033 : 08              >            php         ;save flags
e034 : a552            >            lda zpt
e036 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e039 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e03b : 68              >            pla         ;load status
                       >            eor_flag 0
e03c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e03e : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e041 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e043 : ca                       dex
e044 : 10e3                     bpl tasl2
e046 : a205                     ldx #5
e048 :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
e048 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e04a : 48              >            pha         ;use stack to load status
e04b : b559            >            lda zps,x    ;load to zeropage
e04d : 8552            >            sta zpt
e04f : 28              >            plp
                        
e050 : 0652                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
e052 : 08              >            php         ;save flags
e053 : a552            >            lda zpt
e055 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e058 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e05a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e05b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e05d : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e060 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e062 : ca                       dex
e063 : 10e3                     bpl tasl3
                        
e065 : a205                     ldx #5
e067 :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
e067 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e069 : 48              >            pha         ;use stack to load status
e06a : b559            >            lda zps,x    ;load to zeropage
e06c : 8552            >            sta zpt
e06e : 28              >            plp
                        
e06f : 4652                     lsr zpt
                                tst_z rLSR,fLSR,0
e071 : 08              >            php         ;save flags
e072 : a552            >            lda zpt
e074 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e077 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e079 : 68              >            pla         ;load status
                       >            eor_flag 0
e07a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e07c : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e07f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e081 : ca                       dex
e082 : 10e3                     bpl tlsr2
e084 : a205                     ldx #5
e086 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
e086 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e088 : 48              >            pha         ;use stack to load status
e089 : b559            >            lda zps,x    ;load to zeropage
e08b : 8552            >            sta zpt
e08d : 28              >            plp
                        
e08e : 4652                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
e090 : 08              >            php         ;save flags
e091 : a552            >            lda zpt
e093 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e096 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e098 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e099 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e09b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e09e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e0a0 : ca                       dex
e0a1 : 10e3                     bpl tlsr3
                        
e0a3 : a205                     ldx #5
e0a5 :                  trol2
                                set_z zps,0
                       >            load_flag 0
e0a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e0a7 : 48              >            pha         ;use stack to load status
e0a8 : b559            >            lda zps,x    ;load to zeropage
e0aa : 8552            >            sta zpt
e0ac : 28              >            plp
                        
e0ad : 2652                     rol zpt
                                tst_z rROL,fROL,0
e0af : 08              >            php         ;save flags
e0b0 : a552            >            lda zpt
e0b2 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e0b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e0b7 : 68              >            pla         ;load status
                       >            eor_flag 0
e0b8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e0ba : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e0bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e0bf : ca                       dex
e0c0 : 10e3                     bpl trol2
e0c2 : a205                     ldx #5
e0c4 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
e0c4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e0c6 : 48              >            pha         ;use stack to load status
e0c7 : b559            >            lda zps,x    ;load to zeropage
e0c9 : 8552            >            sta zpt
e0cb : 28              >            plp
                        
e0cc : 2652                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
e0ce : 08              >            php         ;save flags
e0cf : a552            >            lda zpt
e0d1 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e0d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e0d6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e0d7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e0d9 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e0dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e0de : ca                       dex
e0df : 10e3                     bpl trol3
                        
e0e1 : a205                     ldx #5
e0e3 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
e0e3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e0e5 : 48              >            pha         ;use stack to load status
e0e6 : b559            >            lda zps,x    ;load to zeropage
e0e8 : 8552            >            sta zpt
e0ea : 28              >            plp
                        
e0eb : 2652                     rol zpt
                                tst_z rROLc,fROLc,0
e0ed : 08              >            php         ;save flags
e0ee : a552            >            lda zpt
e0f0 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e0f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e0f5 : 68              >            pla         ;load status
                       >            eor_flag 0
e0f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e0f8 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e0fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e0fd : ca                       dex
e0fe : 10e3                     bpl trolc2
e100 : a205                     ldx #5
e102 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
e102 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e104 : 48              >            pha         ;use stack to load status
e105 : b559            >            lda zps,x    ;load to zeropage
e107 : 8552            >            sta zpt
e109 : 28              >            plp
                        
e10a : 2652                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
e10c : 08              >            php         ;save flags
e10d : a552            >            lda zpt
e10f : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e112 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e114 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e115 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e117 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e11a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e11c : ca                       dex
e11d : 10e3                     bpl trolc3
                        
e11f : a205                     ldx #5
e121 :                  tror2
                                set_z zps,0
                       >            load_flag 0
e121 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e123 : 48              >            pha         ;use stack to load status
e124 : b559            >            lda zps,x    ;load to zeropage
e126 : 8552            >            sta zpt
e128 : 28              >            plp
                        
e129 : 6652                     ror zpt
                                tst_z rROR,fROR,0
e12b : 08              >            php         ;save flags
e12c : a552            >            lda zpt
e12e : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e131 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e133 : 68              >            pla         ;load status
                       >            eor_flag 0
e134 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e136 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e139 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e13b : ca                       dex
e13c : 10e3                     bpl tror2
e13e : a205                     ldx #5
e140 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
e140 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e142 : 48              >            pha         ;use stack to load status
e143 : b559            >            lda zps,x    ;load to zeropage
e145 : 8552            >            sta zpt
e147 : 28              >            plp
                        
e148 : 6652                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
e14a : 08              >            php         ;save flags
e14b : a552            >            lda zpt
e14d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e150 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e152 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e153 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e155 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e158 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e15a : ca                       dex
e15b : 10e3                     bpl tror3
                        
e15d : a205                     ldx #5
e15f :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
e15f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e161 : 48              >            pha         ;use stack to load status
e162 : b559            >            lda zps,x    ;load to zeropage
e164 : 8552            >            sta zpt
e166 : 28              >            plp
                        
e167 : 6652                     ror zpt
                                tst_z rRORc,fRORc,0
e169 : 08              >            php         ;save flags
e16a : a552            >            lda zpt
e16c : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e16f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e171 : 68              >            pla         ;load status
                       >            eor_flag 0
e172 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e174 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e177 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e179 : ca                       dex
e17a : 10e3                     bpl trorc2
e17c : a205                     ldx #5
e17e :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
e17e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e180 : 48              >            pha         ;use stack to load status
e181 : b559            >            lda zps,x    ;load to zeropage
e183 : 8552            >            sta zpt
e185 : 28              >            plp
                        
e186 : 6652                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
e188 : 08              >            php         ;save flags
e189 : a552            >            lda zpt
e18b : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e18e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e190 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e191 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e193 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e196 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e198 : ca                       dex
e199 : 10e3                     bpl trorc3
                                next_test
e19b : ad0002          >            lda test_case   ;previous test
e19e : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e1a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
e1a2 : a91f            >            lda #test_num   ;*** next tests' number
e1a4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
e1a7 : a205                     ldx #5
e1a9 :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
e1a9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e1ab : 48              >            pha         ;use stack to load status
e1ac : b559            >            lda zps,x    ;load to memory
e1ae : 8d0302          >            sta abst
e1b1 : 28              >            plp
                        
e1b2 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
e1b5 : 08              >            php         ;save flags
e1b6 : ad0302          >            lda abst
e1b9 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e1bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e1be : 68              >            pla         ;load status
                       >            eor_flag 0
e1bf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e1c1 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e1c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e1c6 : ca                       dex
e1c7 : 10e0                     bpl tasl4
e1c9 : a205                     ldx #5
e1cb :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
e1cb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e1cd : 48              >            pha         ;use stack to load status
e1ce : b559            >            lda zps,x    ;load to memory
e1d0 : 8d0302          >            sta abst
e1d3 : 28              >            plp
                        
e1d4 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
e1d7 : 08              >            php         ;save flags
e1d8 : ad0302          >            lda abst
e1db : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e1de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e1e0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e1e1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e1e3 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e1e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e1e8 : ca                       dex
e1e9 : 10e0                     bpl tasl5
                        
e1eb : a205                     ldx #5
e1ed :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
e1ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e1ef : 48              >            pha         ;use stack to load status
e1f0 : b559            >            lda zps,x    ;load to memory
e1f2 : 8d0302          >            sta abst
e1f5 : 28              >            plp
                        
e1f6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
e1f9 : 08              >            php         ;save flags
e1fa : ad0302          >            lda abst
e1fd : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e200 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e202 : 68              >            pla         ;load status
                       >            eor_flag 0
e203 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e205 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e208 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e20a : ca                       dex
e20b : 10e0                     bpl tlsr4
e20d : a205                     ldx #5
e20f :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
e20f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e211 : 48              >            pha         ;use stack to load status
e212 : b559            >            lda zps,x    ;load to memory
e214 : 8d0302          >            sta abst
e217 : 28              >            plp
                        
e218 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
e21b : 08              >            php         ;save flags
e21c : ad0302          >            lda abst
e21f : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e222 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e224 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e225 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e227 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e22a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e22c : ca                       dex
e22d : 10e0                     bpl tlsr5
                        
e22f : a205                     ldx #5
e231 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
e231 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e233 : 48              >            pha         ;use stack to load status
e234 : b559            >            lda zps,x    ;load to memory
e236 : 8d0302          >            sta abst
e239 : 28              >            plp
                        
e23a : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
e23d : 08              >            php         ;save flags
e23e : ad0302          >            lda abst
e241 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e244 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e246 : 68              >            pla         ;load status
                       >            eor_flag 0
e247 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e249 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e24c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e24e : ca                       dex
e24f : 10e0                     bpl trol4
e251 : a205                     ldx #5
e253 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
e253 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e255 : 48              >            pha         ;use stack to load status
e256 : b559            >            lda zps,x    ;load to memory
e258 : 8d0302          >            sta abst
e25b : 28              >            plp
                        
e25c : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
e25f : 08              >            php         ;save flags
e260 : ad0302          >            lda abst
e263 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e266 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e268 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e269 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e26b : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e26e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e270 : ca                       dex
e271 : 10e0                     bpl trol5
                        
e273 : a205                     ldx #5
e275 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
e275 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e277 : 48              >            pha         ;use stack to load status
e278 : b559            >            lda zps,x    ;load to memory
e27a : 8d0302          >            sta abst
e27d : 28              >            plp
                        
e27e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
e281 : 08              >            php         ;save flags
e282 : ad0302          >            lda abst
e285 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e288 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e28a : 68              >            pla         ;load status
                       >            eor_flag 0
e28b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e28d : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e290 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e292 : ca                       dex
e293 : 10e0                     bpl trolc4
e295 : a205                     ldx #5
e297 :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
e297 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e299 : 48              >            pha         ;use stack to load status
e29a : b559            >            lda zps,x    ;load to memory
e29c : 8d0302          >            sta abst
e29f : 28              >            plp
                        
e2a0 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
e2a3 : 08              >            php         ;save flags
e2a4 : ad0302          >            lda abst
e2a7 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e2aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e2ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e2ad : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e2af : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e2b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e2b4 : ca                       dex
e2b5 : 10e0                     bpl trolc5
                        
e2b7 : a205                     ldx #5
e2b9 :                  tror4
                                set_abs zps,0
                       >            load_flag 0
e2b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e2bb : 48              >            pha         ;use stack to load status
e2bc : b559            >            lda zps,x    ;load to memory
e2be : 8d0302          >            sta abst
e2c1 : 28              >            plp
                        
e2c2 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
e2c5 : 08              >            php         ;save flags
e2c6 : ad0302          >            lda abst
e2c9 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e2cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e2ce : 68              >            pla         ;load status
                       >            eor_flag 0
e2cf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e2d1 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e2d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e2d6 : ca                       dex
e2d7 : 10e0                     bpl tror4
e2d9 : a205                     ldx #5
e2db :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
e2db : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e2dd : 48              >            pha         ;use stack to load status
e2de : b559            >            lda zps,x    ;load to memory
e2e0 : 8d0302          >            sta abst
e2e3 : 28              >            plp
                        
e2e4 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
e2e7 : 08              >            php         ;save flags
e2e8 : ad0302          >            lda abst
e2eb : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e2ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e2f0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e2f1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e2f3 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e2f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e2f8 : ca                       dex
e2f9 : 10e0                     bpl tror5
                        
e2fb : a205                     ldx #5
e2fd :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
e2fd : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e2ff : 48              >            pha         ;use stack to load status
e300 : b559            >            lda zps,x    ;load to memory
e302 : 8d0302          >            sta abst
e305 : 28              >            plp
                        
e306 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
e309 : 08              >            php         ;save flags
e30a : ad0302          >            lda abst
e30d : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e310 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e312 : 68              >            pla         ;load status
                       >            eor_flag 0
e313 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e315 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e318 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e31a : ca                       dex
e31b : 10e0                     bpl trorc4
e31d : a205                     ldx #5
e31f :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
e31f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e321 : 48              >            pha         ;use stack to load status
e322 : b559            >            lda zps,x    ;load to memory
e324 : 8d0302          >            sta abst
e327 : 28              >            plp
                        
e328 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
e32b : 08              >            php         ;save flags
e32c : ad0302          >            lda abst
e32f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e332 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e334 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e335 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e337 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e33a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e33c : ca                       dex
e33d : 10e0                     bpl trorc5
                                next_test
e33f : ad0002          >            lda test_case   ;previous test
e342 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e344 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
e346 : a920            >            lda #test_num   ;*** next tests' number
e348 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
e34b : a205                     ldx #5
e34d :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
e34d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e34f : 48              >            pha         ;use stack to load status
e350 : b559            >            lda zps,x    ;load to indexed zeropage
e352 : 9552            >            sta zpt,x
e354 : 28              >            plp
                        
e355 : 1652                     asl zpt,x
                                tst_zx rASL,fASL,0
e357 : 08              >            php         ;save flags
e358 : b552            >            lda zpt,x
e35a : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e35d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e35f : 68              >            pla         ;load status
                       >            eor_flag 0
e360 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e362 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e365 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e367 : ca                       dex
e368 : 10e3                     bpl tasl6
e36a : a205                     ldx #5
e36c :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
e36c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e36e : 48              >            pha         ;use stack to load status
e36f : b559            >            lda zps,x    ;load to indexed zeropage
e371 : 9552            >            sta zpt,x
e373 : 28              >            plp
                        
e374 : 1652                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
e376 : 08              >            php         ;save flags
e377 : b552            >            lda zpt,x
e379 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e37c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e37e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e37f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e381 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e384 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e386 : ca                       dex
e387 : 10e3                     bpl tasl7
                        
e389 : a205                     ldx #5
e38b :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
e38b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e38d : 48              >            pha         ;use stack to load status
e38e : b559            >            lda zps,x    ;load to indexed zeropage
e390 : 9552            >            sta zpt,x
e392 : 28              >            plp
                        
e393 : 5652                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
e395 : 08              >            php         ;save flags
e396 : b552            >            lda zpt,x
e398 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e39b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e39d : 68              >            pla         ;load status
                       >            eor_flag 0
e39e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e3a0 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e3a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e3a5 : ca                       dex
e3a6 : 10e3                     bpl tlsr6
e3a8 : a205                     ldx #5
e3aa :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
e3aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e3ac : 48              >            pha         ;use stack to load status
e3ad : b559            >            lda zps,x    ;load to indexed zeropage
e3af : 9552            >            sta zpt,x
e3b1 : 28              >            plp
                        
e3b2 : 5652                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
e3b4 : 08              >            php         ;save flags
e3b5 : b552            >            lda zpt,x
e3b7 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e3ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e3bc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e3bd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e3bf : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e3c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e3c4 : ca                       dex
e3c5 : 10e3                     bpl tlsr7
                        
e3c7 : a205                     ldx #5
e3c9 :                  trol6
                                set_zx zps,0
                       >            load_flag 0
e3c9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e3cb : 48              >            pha         ;use stack to load status
e3cc : b559            >            lda zps,x    ;load to indexed zeropage
e3ce : 9552            >            sta zpt,x
e3d0 : 28              >            plp
                        
e3d1 : 3652                     rol zpt,x
                                tst_zx rROL,fROL,0
e3d3 : 08              >            php         ;save flags
e3d4 : b552            >            lda zpt,x
e3d6 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e3d9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e3db : 68              >            pla         ;load status
                       >            eor_flag 0
e3dc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e3de : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e3e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e3e3 : ca                       dex
e3e4 : 10e3                     bpl trol6
e3e6 : a205                     ldx #5
e3e8 :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
e3e8 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e3ea : 48              >            pha         ;use stack to load status
e3eb : b559            >            lda zps,x    ;load to indexed zeropage
e3ed : 9552            >            sta zpt,x
e3ef : 28              >            plp
                        
e3f0 : 3652                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
e3f2 : 08              >            php         ;save flags
e3f3 : b552            >            lda zpt,x
e3f5 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e3f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e3fa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e3fb : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e3fd : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e400 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e402 : ca                       dex
e403 : 10e3                     bpl trol7
                        
e405 : a205                     ldx #5
e407 :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
e407 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e409 : 48              >            pha         ;use stack to load status
e40a : b559            >            lda zps,x    ;load to indexed zeropage
e40c : 9552            >            sta zpt,x
e40e : 28              >            plp
                        
e40f : 3652                     rol zpt,x
                                tst_zx rROLc,fROLc,0
e411 : 08              >            php         ;save flags
e412 : b552            >            lda zpt,x
e414 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e417 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e419 : 68              >            pla         ;load status
                       >            eor_flag 0
e41a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e41c : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e41f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e421 : ca                       dex
e422 : 10e3                     bpl trolc6
e424 : a205                     ldx #5
e426 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
e426 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e428 : 48              >            pha         ;use stack to load status
e429 : b559            >            lda zps,x    ;load to indexed zeropage
e42b : 9552            >            sta zpt,x
e42d : 28              >            plp
                        
e42e : 3652                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
e430 : 08              >            php         ;save flags
e431 : b552            >            lda zpt,x
e433 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e436 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e438 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e439 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e43b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e43e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e440 : ca                       dex
e441 : 10e3                     bpl trolc7
                        
e443 : a205                     ldx #5
e445 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
e445 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e447 : 48              >            pha         ;use stack to load status
e448 : b559            >            lda zps,x    ;load to indexed zeropage
e44a : 9552            >            sta zpt,x
e44c : 28              >            plp
                        
e44d : 7652                     ror zpt,x
                                tst_zx rROR,fROR,0
e44f : 08              >            php         ;save flags
e450 : b552            >            lda zpt,x
e452 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e455 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e457 : 68              >            pla         ;load status
                       >            eor_flag 0
e458 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e45a : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e45d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e45f : ca                       dex
e460 : 10e3                     bpl tror6
e462 : a205                     ldx #5
e464 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
e464 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e466 : 48              >            pha         ;use stack to load status
e467 : b559            >            lda zps,x    ;load to indexed zeropage
e469 : 9552            >            sta zpt,x
e46b : 28              >            plp
                        
e46c : 7652                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
e46e : 08              >            php         ;save flags
e46f : b552            >            lda zpt,x
e471 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e474 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e476 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e477 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e479 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e47c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e47e : ca                       dex
e47f : 10e3                     bpl tror7
                        
e481 : a205                     ldx #5
e483 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
e483 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e485 : 48              >            pha         ;use stack to load status
e486 : b559            >            lda zps,x    ;load to indexed zeropage
e488 : 9552            >            sta zpt,x
e48a : 28              >            plp
                        
e48b : 7652                     ror zpt,x
                                tst_zx rRORc,fRORc,0
e48d : 08              >            php         ;save flags
e48e : b552            >            lda zpt,x
e490 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e493 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e495 : 68              >            pla         ;load status
                       >            eor_flag 0
e496 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e498 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e49b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e49d : ca                       dex
e49e : 10e3                     bpl trorc6
e4a0 : a205                     ldx #5
e4a2 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
e4a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e4a4 : 48              >            pha         ;use stack to load status
e4a5 : b559            >            lda zps,x    ;load to indexed zeropage
e4a7 : 9552            >            sta zpt,x
e4a9 : 28              >            plp
                        
e4aa : 7652                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
e4ac : 08              >            php         ;save flags
e4ad : b552            >            lda zpt,x
e4af : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e4b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e4b4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e4b5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e4b7 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e4ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e4bc : ca                       dex
e4bd : 10e3                     bpl trorc7
                                next_test
e4bf : ad0002          >            lda test_case   ;previous test
e4c2 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e4c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
e4c6 : a921            >            lda #test_num   ;*** next tests' number
e4c8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - abs indexed
e4cb : a205                     ldx #5
e4cd :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
e4cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e4cf : 48              >            pha         ;use stack to load status
e4d0 : b559            >            lda zps,x    ;load to indexed memory
e4d2 : 9d0302          >            sta abst,x
e4d5 : 28              >            plp
                        
e4d6 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
e4d9 : 08              >            php         ;save flags
e4da : bd0302          >            lda abst,x
e4dd : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e4e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e4e2 : 68              >            pla         ;load status
                       >            eor_flag 0
e4e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e4e5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e4e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e4ea : ca                       dex
e4eb : 10e0                     bpl tasl8
e4ed : a205                     ldx #5
e4ef :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
e4ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e4f1 : 48              >            pha         ;use stack to load status
e4f2 : b559            >            lda zps,x    ;load to indexed memory
e4f4 : 9d0302          >            sta abst,x
e4f7 : 28              >            plp
                        
e4f8 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
e4fb : 08              >            php         ;save flags
e4fc : bd0302          >            lda abst,x
e4ff : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
e502 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e504 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e505 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e507 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
e50a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e50c : ca                       dex
e50d : 10e0                     bpl tasl9
                        
e50f : a205                     ldx #5
e511 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
e511 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e513 : 48              >            pha         ;use stack to load status
e514 : b559            >            lda zps,x    ;load to indexed memory
e516 : 9d0302          >            sta abst,x
e519 : 28              >            plp
                        
e51a : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
e51d : 08              >            php         ;save flags
e51e : bd0302          >            lda abst,x
e521 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e524 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e526 : 68              >            pla         ;load status
                       >            eor_flag 0
e527 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e529 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e52c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e52e : ca                       dex
e52f : 10e0                     bpl tlsr8
e531 : a205                     ldx #5
e533 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
e533 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e535 : 48              >            pha         ;use stack to load status
e536 : b559            >            lda zps,x    ;load to indexed memory
e538 : 9d0302          >            sta abst,x
e53b : 28              >            plp
                        
e53c : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
e53f : 08              >            php         ;save flags
e540 : bd0302          >            lda abst,x
e543 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
e546 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e548 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e549 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e54b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
e54e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e550 : ca                       dex
e551 : 10e0                     bpl tlsr9
                        
e553 : a205                     ldx #5
e555 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
e555 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e557 : 48              >            pha         ;use stack to load status
e558 : b559            >            lda zps,x    ;load to indexed memory
e55a : 9d0302          >            sta abst,x
e55d : 28              >            plp
                        
e55e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
e561 : 08              >            php         ;save flags
e562 : bd0302          >            lda abst,x
e565 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e568 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e56a : 68              >            pla         ;load status
                       >            eor_flag 0
e56b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e56d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e570 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e572 : ca                       dex
e573 : 10e0                     bpl trol8
e575 : a205                     ldx #5
e577 :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
e577 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e579 : 48              >            pha         ;use stack to load status
e57a : b559            >            lda zps,x    ;load to indexed memory
e57c : 9d0302          >            sta abst,x
e57f : 28              >            plp
                        
e580 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
e583 : 08              >            php         ;save flags
e584 : bd0302          >            lda abst,x
e587 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
e58a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e58c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e58d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e58f : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
e592 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e594 : ca                       dex
e595 : 10e0                     bpl trol9
                        
e597 : a205                     ldx #5
e599 :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
e599 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e59b : 48              >            pha         ;use stack to load status
e59c : b559            >            lda zps,x    ;load to indexed memory
e59e : 9d0302          >            sta abst,x
e5a1 : 28              >            plp
                        
e5a2 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
e5a5 : 08              >            php         ;save flags
e5a6 : bd0302          >            lda abst,x
e5a9 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e5ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e5ae : 68              >            pla         ;load status
                       >            eor_flag 0
e5af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e5b1 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e5b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e5b6 : ca                       dex
e5b7 : 10e0                     bpl trolc8
e5b9 : a205                     ldx #5
e5bb :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
e5bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e5bd : 48              >            pha         ;use stack to load status
e5be : b559            >            lda zps,x    ;load to indexed memory
e5c0 : 9d0302          >            sta abst,x
e5c3 : 28              >            plp
                        
e5c4 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
e5c7 : 08              >            php         ;save flags
e5c8 : bd0302          >            lda abst,x
e5cb : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
e5ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e5d0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e5d1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e5d3 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
e5d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e5d8 : ca                       dex
e5d9 : 10e0                     bpl trolc9
                        
e5db : a205                     ldx #5
e5dd :                  tror8
                                set_absx zps,0
                       >            load_flag 0
e5dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e5df : 48              >            pha         ;use stack to load status
e5e0 : b559            >            lda zps,x    ;load to indexed memory
e5e2 : 9d0302          >            sta abst,x
e5e5 : 28              >            plp
                        
e5e6 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
e5e9 : 08              >            php         ;save flags
e5ea : bd0302          >            lda abst,x
e5ed : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e5f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e5f2 : 68              >            pla         ;load status
                       >            eor_flag 0
e5f3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e5f5 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e5f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e5fa : ca                       dex
e5fb : 10e0                     bpl tror8
e5fd : a205                     ldx #5
e5ff :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
e5ff : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
e601 : 48              >            pha         ;use stack to load status
e602 : b559            >            lda zps,x    ;load to indexed memory
e604 : 9d0302          >            sta abst,x
e607 : 28              >            plp
                        
e608 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
e60b : 08              >            php         ;save flags
e60c : bd0302          >            lda abst,x
e60f : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
e612 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e614 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e615 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e617 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
e61a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e61c : ca                       dex
e61d : 10e0                     bpl tror9
                        
e61f : a205                     ldx #5
e621 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
e621 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
e623 : 48              >            pha         ;use stack to load status
e624 : b559            >            lda zps,x    ;load to indexed memory
e626 : 9d0302          >            sta abst,x
e629 : 28              >            plp
                        
e62a : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
e62d : 08              >            php         ;save flags
e62e : bd0302          >            lda abst,x
e631 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e634 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e636 : 68              >            pla         ;load status
                       >            eor_flag 0
e637 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e639 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e63c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e63e : ca                       dex
e63f : 10e0                     bpl trorc8
e641 : a205                     ldx #5
e643 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
e643 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e645 : 48              >            pha         ;use stack to load status
e646 : b559            >            lda zps,x    ;load to indexed memory
e648 : 9d0302          >            sta abst,x
e64b : 28              >            plp
                        
e64c : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
e64f : 08              >            php         ;save flags
e650 : bd0302          >            lda abst,x
e653 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
e656 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e658 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
e659 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
e65b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
e65e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e660 : ca                       dex
e661 : 10e0                     bpl trorc9
                                next_test
e663 : ad0002          >            lda test_case   ;previous test
e666 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e668 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
e66a : a922            >            lda #test_num   ;*** next tests' number
e66c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
e66f : a200                     ldx #0
e671 : a97e                     lda #$7e
e673 : 8552                     sta zpt
e675 :                  tinc
                                set_stat 0
                       >            load_flag 0
e675 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e677 : 48              >            pha         ;use stack to load status
e678 : 28              >            plp
                        
e679 : e652                     inc zpt
                                tst_z rINC,fINC,0
e67b : 08              >            php         ;save flags
e67c : a552            >            lda zpt
e67e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e681 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e683 : 68              >            pla         ;load status
                       >            eor_flag 0
e684 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e686 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e689 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e68b : e8                       inx
e68c : e002                     cpx #2
e68e : d004                     bne tinc1
e690 : a9fe                     lda #$fe
e692 : 8552                     sta zpt
e694 : e005             tinc1   cpx #5
e696 : d0dd                     bne tinc
e698 : ca                       dex
e699 : e652                     inc zpt
e69b :                  tdec
                                set_stat 0
                       >            load_flag 0
e69b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e69d : 48              >            pha         ;use stack to load status
e69e : 28              >            plp
                        
e69f : c652                     dec zpt
                                tst_z rINC,fINC,0
e6a1 : 08              >            php         ;save flags
e6a2 : a552            >            lda zpt
e6a4 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e6a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e6a9 : 68              >            pla         ;load status
                       >            eor_flag 0
e6aa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e6ac : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e6af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e6b1 : ca                       dex
e6b2 : 300a                     bmi tdec1
e6b4 : e001                     cpx #1
e6b6 : d0e3                     bne tdec
e6b8 : a981                     lda #$81
e6ba : 8552                     sta zpt
e6bc : d0dd                     bne tdec
e6be :                  tdec1
e6be : a200                     ldx #0
e6c0 : a97e                     lda #$7e
e6c2 : 8552                     sta zpt
e6c4 :                  tinc10
                                set_stat $ff
                       >            load_flag $ff
e6c4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e6c6 : 48              >            pha         ;use stack to load status
e6c7 : 28              >            plp
                        
e6c8 : e652                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
e6ca : 08              >            php         ;save flags
e6cb : a552            >            lda zpt
e6cd : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e6d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e6d2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e6d3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e6d5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e6d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e6da : e8                       inx
e6db : e002                     cpx #2
e6dd : d004                     bne tinc11
e6df : a9fe                     lda #$fe
e6e1 : 8552                     sta zpt
e6e3 : e005             tinc11  cpx #5
e6e5 : d0dd                     bne tinc10
e6e7 : ca                       dex
e6e8 : e652                     inc zpt
e6ea :                  tdec10
                                set_stat $ff
                       >            load_flag $ff
e6ea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e6ec : 48              >            pha         ;use stack to load status
e6ed : 28              >            plp
                        
e6ee : c652                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
e6f0 : 08              >            php         ;save flags
e6f1 : a552            >            lda zpt
e6f3 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e6f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e6f8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e6f9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e6fb : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e6fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e700 : ca                       dex
e701 : 300a                     bmi tdec11
e703 : e001                     cpx #1
e705 : d0e3                     bne tdec10
e707 : a981                     lda #$81
e709 : 8552                     sta zpt
e70b : d0dd                     bne tdec10
e70d :                  tdec11
                                next_test
e70d : ad0002          >            lda test_case   ;previous test
e710 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e712 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
e714 : a923            >            lda #test_num   ;*** next tests' number
e716 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
e719 : a200                     ldx #0
e71b : a97e                     lda #$7e
e71d : 8d0302                   sta abst
e720 :                  tinc2
                                set_stat 0
                       >            load_flag 0
e720 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e722 : 48              >            pha         ;use stack to load status
e723 : 28              >            plp
                        
e724 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
e727 : 08              >            php         ;save flags
e728 : ad0302          >            lda abst
e72b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e72e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e730 : 68              >            pla         ;load status
                       >            eor_flag 0
e731 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e733 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e736 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e738 : e8                       inx
e739 : e002                     cpx #2
e73b : d005                     bne tinc3
e73d : a9fe                     lda #$fe
e73f : 8d0302                   sta abst
e742 : e005             tinc3   cpx #5
e744 : d0da                     bne tinc2
e746 : ca                       dex
e747 : ee0302                   inc abst
e74a :                  tdec2
                                set_stat 0
                       >            load_flag 0
e74a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e74c : 48              >            pha         ;use stack to load status
e74d : 28              >            plp
                        
e74e : ce0302                   dec abst
                                tst_abs rINC,fINC,0
e751 : 08              >            php         ;save flags
e752 : ad0302          >            lda abst
e755 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e758 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e75a : 68              >            pla         ;load status
                       >            eor_flag 0
e75b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e75d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e760 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e762 : ca                       dex
e763 : 300b                     bmi tdec3
e765 : e001                     cpx #1
e767 : d0e1                     bne tdec2
e769 : a981                     lda #$81
e76b : 8d0302                   sta abst
e76e : d0da                     bne tdec2
e770 :                  tdec3
e770 : a200                     ldx #0
e772 : a97e                     lda #$7e
e774 : 8d0302                   sta abst
e777 :                  tinc12
                                set_stat $ff
                       >            load_flag $ff
e777 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e779 : 48              >            pha         ;use stack to load status
e77a : 28              >            plp
                        
e77b : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
e77e : 08              >            php         ;save flags
e77f : ad0302          >            lda abst
e782 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e785 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e787 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e788 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e78a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e78d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e78f : e8                       inx
e790 : e002                     cpx #2
e792 : d005                     bne tinc13
e794 : a9fe                     lda #$fe
e796 : 8d0302                   sta abst
e799 : e005             tinc13   cpx #5
e79b : d0da                     bne tinc12
e79d : ca                       dex
e79e : ee0302                   inc abst
e7a1 :                  tdec12
                                set_stat $ff
                       >            load_flag $ff
e7a1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e7a3 : 48              >            pha         ;use stack to load status
e7a4 : 28              >            plp
                        
e7a5 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
e7a8 : 08              >            php         ;save flags
e7a9 : ad0302          >            lda abst
e7ac : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e7af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e7b1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e7b2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e7b4 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e7b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e7b9 : ca                       dex
e7ba : 300b                     bmi tdec13
e7bc : e001                     cpx #1
e7be : d0e1                     bne tdec12
e7c0 : a981                     lda #$81
e7c2 : 8d0302                   sta abst
e7c5 : d0da                     bne tdec12
e7c7 :                  tdec13
                                next_test
e7c7 : ad0002          >            lda test_case   ;previous test
e7ca : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e7cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
e7ce : a924            >            lda #test_num   ;*** next tests' number
e7d0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
e7d3 : a200                     ldx #0
e7d5 : a97e                     lda #$7e
e7d7 : 9552             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
e7d9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e7db : 48              >            pha         ;use stack to load status
e7dc : 28              >            plp
                        
e7dd : f652                     inc zpt,x
                                tst_zx rINC,fINC,0
e7df : 08              >            php         ;save flags
e7e0 : b552            >            lda zpt,x
e7e2 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e7e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e7e7 : 68              >            pla         ;load status
                       >            eor_flag 0
e7e8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e7ea : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e7ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e7ef : b552                     lda zpt,x
e7f1 : e8                       inx
e7f2 : e002                     cpx #2
e7f4 : d002                     bne tinc5
e7f6 : a9fe                     lda #$fe
e7f8 : e005             tinc5   cpx #5
e7fa : d0db                     bne tinc4
e7fc : ca                       dex
e7fd : a902                     lda #2
e7ff : 9552             tdec4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
e801 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e803 : 48              >            pha         ;use stack to load status
e804 : 28              >            plp
                        
e805 : d652                     dec zpt,x
                                tst_zx rINC,fINC,0
e807 : 08              >            php         ;save flags
e808 : b552            >            lda zpt,x
e80a : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e80d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e80f : 68              >            pla         ;load status
                       >            eor_flag 0
e810 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e812 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e817 : b552                     lda zpt,x
e819 : ca                       dex
e81a : 3008                     bmi tdec5
e81c : e001                     cpx #1
e81e : d0df                     bne tdec4
e820 : a981                     lda #$81
e822 : d0db                     bne tdec4
e824 :                  tdec5
e824 : a200                     ldx #0
e826 : a97e                     lda #$7e
e828 : 9552             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
e82a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e82c : 48              >            pha         ;use stack to load status
e82d : 28              >            plp
                        
e82e : f652                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
e830 : 08              >            php         ;save flags
e831 : b552            >            lda zpt,x
e833 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e836 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e838 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e839 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e83b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e83e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e840 : b552                     lda zpt,x
e842 : e8                       inx
e843 : e002                     cpx #2
e845 : d002                     bne tinc15
e847 : a9fe                     lda #$fe
e849 : e005             tinc15  cpx #5
e84b : d0db                     bne tinc14
e84d : ca                       dex
e84e : a902                     lda #2
e850 : 9552             tdec14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
e852 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e854 : 48              >            pha         ;use stack to load status
e855 : 28              >            plp
                        
e856 : d652                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
e858 : 08              >            php         ;save flags
e859 : b552            >            lda zpt,x
e85b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e85e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e860 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e861 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e863 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e866 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e868 : b552                     lda zpt,x
e86a : ca                       dex
e86b : 3008                     bmi tdec15
e86d : e001                     cpx #1
e86f : d0df                     bne tdec14
e871 : a981                     lda #$81
e873 : d0db                     bne tdec14
e875 :                  tdec15
                                next_test
e875 : ad0002          >            lda test_case   ;previous test
e878 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e87a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
e87c : a925            >            lda #test_num   ;*** next tests' number
e87e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
e881 : a200                     ldx #0
e883 : a97e                     lda #$7e
e885 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
e888 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e88a : 48              >            pha         ;use stack to load status
e88b : 28              >            plp
                        
e88c : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
e88f : 08              >            php         ;save flags
e890 : bd0302          >            lda abst,x
e893 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e896 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e898 : 68              >            pla         ;load status
                       >            eor_flag 0
e899 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e89b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e89e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e8a0 : bd0302                   lda abst,x
e8a3 : e8                       inx
e8a4 : e002                     cpx #2
e8a6 : d002                     bne tinc7
e8a8 : a9fe                     lda #$fe
e8aa : e005             tinc7   cpx #5
e8ac : d0d7                     bne tinc6
e8ae : ca                       dex
e8af : a902                     lda #2
e8b1 : 9d0302           tdec6   sta abst,x
                                set_stat 0
                       >            load_flag 0
e8b4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e8b6 : 48              >            pha         ;use stack to load status
e8b7 : 28              >            plp
                        
e8b8 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
e8bb : 08              >            php         ;save flags
e8bc : bd0302          >            lda abst,x
e8bf : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e8c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e8c4 : 68              >            pla         ;load status
                       >            eor_flag 0
e8c5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e8c7 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e8ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e8cc : bd0302                   lda abst,x
e8cf : ca                       dex
e8d0 : 3008                     bmi tdec7
e8d2 : e001                     cpx #1
e8d4 : d0db                     bne tdec6
e8d6 : a981                     lda #$81
e8d8 : d0d7                     bne tdec6
e8da :                  tdec7
e8da : a200                     ldx #0
e8dc : a97e                     lda #$7e
e8de : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
e8e1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e8e3 : 48              >            pha         ;use stack to load status
e8e4 : 28              >            plp
                        
e8e5 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
e8e8 : 08              >            php         ;save flags
e8e9 : bd0302          >            lda abst,x
e8ec : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e8ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e8f1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e8f2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e8f4 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e8f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e8f9 : bd0302                   lda abst,x
e8fc : e8                       inx
e8fd : e002                     cpx #2
e8ff : d002                     bne tinc17
e901 : a9fe                     lda #$fe
e903 : e005             tinc17  cpx #5
e905 : d0d7                     bne tinc16
e907 : ca                       dex
e908 : a902                     lda #2
e90a : 9d0302           tdec16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
e90d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e90f : 48              >            pha         ;use stack to load status
e910 : 28              >            plp
                        
e911 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
e914 : 08              >            php         ;save flags
e915 : bd0302          >            lda abst,x
e918 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
e91b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e91d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e91e : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e920 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
e923 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e925 : bd0302                   lda abst,x
e928 : ca                       dex
e929 : 3008                     bmi tdec17
e92b : e001                     cpx #1
e92d : d0db                     bne tdec16
e92f : a981                     lda #$81
e931 : d0d7                     bne tdec16
e933 :                  tdec17
                                next_test
e933 : ad0002          >            lda test_case   ;previous test
e936 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
e938 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
e93a : a926            >            lda #test_num   ;*** next tests' number
e93c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
e93f : a203                     ldx #3          ;immediate
e941 : b564             tand    lda zpAN,x
e943 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
e946 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e948 : 48              >            pha         ;use stack to load status
e949 : bd6b02          >            lda absANa,x    ;precharge accu
e94c : 28              >            plp
                        
e94d : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
e950 : 08              >            php         ;save flags
e951 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e954 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e956 : 68              >            pla         ;load status
                       >            eor_flag 0
e957 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e959 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
e95c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e95e : ca                       dex
e95f : 10e0                     bpl tand
e961 : a203                     ldx #3
e963 : b564             tand1   lda zpAN,x
e965 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
e968 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e96a : 48              >            pha         ;use stack to load status
e96b : bd6b02          >            lda absANa,x    ;precharge accu
e96e : 28              >            plp
                        
e96f : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
e972 : 08              >            php         ;save flags
e973 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e976 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e978 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e979 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e97b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
e97e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e980 : ca                       dex
e981 : 10e0                     bpl tand1
                        
e983 : a203                     ldx #3      ;zp
e985 : b564             tand2   lda zpAN,x
e987 : 8552                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
e989 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e98b : 48              >            pha         ;use stack to load status
e98c : bd6b02          >            lda absANa,x    ;precharge accu
e98f : 28              >            plp
                        
e990 : 2552                     and zpt
                                tst_ax  absrlo,absflo,0
e992 : 08              >            php         ;save flags
e993 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e996 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e998 : 68              >            pla         ;load status
                       >            eor_flag 0
e999 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e99b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
e99e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e9a0 : ca                       dex
e9a1 : 10e2                     bpl tand2
e9a3 : a203                     ldx #3
e9a5 : b564             tand3   lda zpAN,x
e9a7 : 8552                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
e9a9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e9ab : 48              >            pha         ;use stack to load status
e9ac : bd6b02          >            lda absANa,x    ;precharge accu
e9af : 28              >            plp
                        
e9b0 : 2552                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
e9b2 : 08              >            php         ;save flags
e9b3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e9b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e9b8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e9b9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e9bb : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
e9be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e9c0 : ca                       dex
e9c1 : 10e2                     bpl tand3
                        
e9c3 : a203                     ldx #3      ;abs
e9c5 : b564             tand4   lda zpAN,x
e9c7 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
e9ca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
e9cc : 48              >            pha         ;use stack to load status
e9cd : bd6b02          >            lda absANa,x    ;precharge accu
e9d0 : 28              >            plp
                        
e9d1 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
e9d4 : 08              >            php         ;save flags
e9d5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e9d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e9da : 68              >            pla         ;load status
                       >            eor_flag 0
e9db : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
e9dd : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
e9e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
e9e2 : ca                       dex
e9e3 : 10e0                     bpl tand4
e9e5 : a203                     ldx #3
e9e7 : b564             tand5   lda zpAN,x
e9e9 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
e9ec : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
e9ee : 48              >            pha         ;use stack to load status
e9ef : bd6b02          >            lda absANa,x    ;precharge accu
e9f2 : 28              >            plp
                        
e9f3 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
e9f6 : 08              >            php         ;save flags
e9f7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
e9fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
e9fc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
e9fd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
e9ff : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ea02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea04 : ca                       dex
ea05 : 1002                     bpl tand6
                        
ea07 : a203                     ldx #3      ;zp,x
ea09 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
ea09 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ea0b : 48              >            pha         ;use stack to load status
ea0c : bd6b02          >            lda absANa,x    ;precharge accu
ea0f : 28              >            plp
                        
ea10 : 3564                     and zpAN,x
                                tst_ax  absrlo,absflo,0
ea12 : 08              >            php         ;save flags
ea13 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ea16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ea18 : 68              >            pla         ;load status
                       >            eor_flag 0
ea19 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ea1b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ea1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea20 : ca                       dex
ea21 : 10e6                     bpl tand6
ea23 : a203                     ldx #3
ea25 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
ea25 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ea27 : 48              >            pha         ;use stack to load status
ea28 : bd6b02          >            lda absANa,x    ;precharge accu
ea2b : 28              >            plp
                        
ea2c : 3564                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
ea2e : 08              >            php         ;save flags
ea2f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ea32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ea34 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ea35 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ea37 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ea3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea3c : ca                       dex
ea3d : 10e6                     bpl tand7
                        
ea3f : a203                     ldx #3      ;abs,x
ea41 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
ea41 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ea43 : 48              >            pha         ;use stack to load status
ea44 : bd6b02          >            lda absANa,x    ;precharge accu
ea47 : 28              >            plp
                        
ea48 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
ea4b : 08              >            php         ;save flags
ea4c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ea4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ea51 : 68              >            pla         ;load status
                       >            eor_flag 0
ea52 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ea54 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ea57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea59 : ca                       dex
ea5a : 10e5                     bpl tand8
ea5c : a203                     ldx #3
ea5e :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
ea5e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ea60 : 48              >            pha         ;use stack to load status
ea61 : bd6b02          >            lda absANa,x    ;precharge accu
ea64 : 28              >            plp
                        
ea65 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
ea68 : 08              >            php         ;save flags
ea69 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ea6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ea6e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ea6f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ea71 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ea74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea76 : ca                       dex
ea77 : 10e5                     bpl tand9
                        
ea79 : a003                     ldy #3      ;abs,y
ea7b :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
ea7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ea7d : 48              >            pha         ;use stack to load status
ea7e : b96b02          >            lda absANa,y    ;precharge accu
ea81 : 28              >            plp
                        
ea82 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
ea85 : 08              >            php         ;save flags
ea86 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ea89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ea8b : 68              >            pla         ;load status
                       >            eor_flag 0
ea8c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ea8e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ea91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ea93 : 88                       dey
ea94 : 10e5                     bpl tand10
ea96 : a003                     ldy #3
ea98 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
ea98 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ea9a : 48              >            pha         ;use stack to load status
ea9b : b96b02          >            lda absANa,y    ;precharge accu
ea9e : 28              >            plp
                        
ea9f : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
eaa2 : 08              >            php         ;save flags
eaa3 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eaa6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eaa8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eaa9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eaab : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eaae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eab0 : 88                       dey
eab1 : 10e5                     bpl tand11
                        
eab3 : a206                     ldx #6      ;(zp,x)
eab5 : a003                     ldy #3
eab7 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
eab7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eab9 : 48              >            pha         ;use stack to load status
eaba : b96b02          >            lda absANa,y    ;precharge accu
eabd : 28              >            plp
                        
eabe : 2182                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
eac0 : 08              >            php         ;save flags
eac1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eac4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eac6 : 68              >            pla         ;load status
                       >            eor_flag 0
eac7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eac9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eacc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eace : ca                       dex
eacf : ca                       dex
ead0 : 88                       dey
ead1 : 10e4                     bpl tand12
ead3 : a206                     ldx #6
ead5 : a003                     ldy #3
ead7 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
ead7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ead9 : 48              >            pha         ;use stack to load status
eada : b96b02          >            lda absANa,y    ;precharge accu
eadd : 28              >            plp
                        
eade : 2182                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
eae0 : 08              >            php         ;save flags
eae1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eae4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eae6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eae7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eae9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eaec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eaee : ca                       dex
eaef : ca                       dex
eaf0 : 88                       dey
eaf1 : 10e4                     bpl tand13
                        
eaf3 : a003                     ldy #3      ;(zp),y
eaf5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
eaf5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eaf7 : 48              >            pha         ;use stack to load status
eaf8 : b96b02          >            lda absANa,y    ;precharge accu
eafb : 28              >            plp
                        
eafc : 3182                     and (indAN),y
                                tst_ay  absrlo,absflo,0
eafe : 08              >            php         ;save flags
eaff : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eb02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eb04 : 68              >            pla         ;load status
                       >            eor_flag 0
eb05 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eb07 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eb0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eb0c : 88                       dey
eb0d : 10e6                     bpl tand14
eb0f : a003                     ldy #3
eb11 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
eb11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
eb13 : 48              >            pha         ;use stack to load status
eb14 : b96b02          >            lda absANa,y    ;precharge accu
eb17 : 28              >            plp
                        
eb18 : 3182                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
eb1a : 08              >            php         ;save flags
eb1b : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eb1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eb20 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eb21 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eb23 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eb26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eb28 : 88                       dey
eb29 : 10e6                     bpl tand15
                                next_test
eb2b : ad0002          >            lda test_case   ;previous test
eb2e : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
eb30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
eb32 : a927            >            lda #test_num   ;*** next tests' number
eb34 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
eb37 : a203                     ldx #3          ;immediate - self modifying code
eb39 : b568             teor    lda zpEO,x
eb3b : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
eb3e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eb40 : 48              >            pha         ;use stack to load status
eb41 : bd6f02          >            lda absEOa,x    ;precharge accu
eb44 : 28              >            plp
                        
eb45 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
eb48 : 08              >            php         ;save flags
eb49 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
eb4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eb4e : 68              >            pla         ;load status
                       >            eor_flag 0
eb4f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eb51 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
eb54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eb56 : ca                       dex
eb57 : 10e0                     bpl teor
eb59 : a203                     ldx #3
eb5b : b568             teor1   lda zpEO,x
eb5d : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
eb60 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
eb62 : 48              >            pha         ;use stack to load status
eb63 : bd6f02          >            lda absEOa,x    ;precharge accu
eb66 : 28              >            plp
                        
eb67 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
eb6a : 08              >            php         ;save flags
eb6b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
eb6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eb70 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eb71 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eb73 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
eb76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eb78 : ca                       dex
eb79 : 10e0                     bpl teor1
                        
eb7b : a203                     ldx #3      ;zp
eb7d : b568             teor2    lda zpEO,x
eb7f : 8552                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
eb81 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eb83 : 48              >            pha         ;use stack to load status
eb84 : bd6f02          >            lda absEOa,x    ;precharge accu
eb87 : 28              >            plp
                        
eb88 : 4552                     eor zpt
                                tst_ax  absrlo,absflo,0
eb8a : 08              >            php         ;save flags
eb8b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
eb8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eb90 : 68              >            pla         ;load status
                       >            eor_flag 0
eb91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eb93 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
eb96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eb98 : ca                       dex
eb99 : 10e2                     bpl teor2
eb9b : a203                     ldx #3
eb9d : b568             teor3   lda zpEO,x
eb9f : 8552                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
eba1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
eba3 : 48              >            pha         ;use stack to load status
eba4 : bd6f02          >            lda absEOa,x    ;precharge accu
eba7 : 28              >            plp
                        
eba8 : 4552                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
ebaa : 08              >            php         ;save flags
ebab : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ebae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ebb0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ebb1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ebb3 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ebb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ebb8 : ca                       dex
ebb9 : 10e2                     bpl teor3
                        
ebbb : a203                     ldx #3      ;abs
ebbd : b568             teor4   lda zpEO,x
ebbf : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
ebc2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ebc4 : 48              >            pha         ;use stack to load status
ebc5 : bd6f02          >            lda absEOa,x    ;precharge accu
ebc8 : 28              >            plp
                        
ebc9 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
ebcc : 08              >            php         ;save flags
ebcd : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ebd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ebd2 : 68              >            pla         ;load status
                       >            eor_flag 0
ebd3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ebd5 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ebd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ebda : ca                       dex
ebdb : 10e0                     bpl teor4
ebdd : a203                     ldx #3
ebdf : b568             teor5   lda zpEO,x
ebe1 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ebe4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ebe6 : 48              >            pha         ;use stack to load status
ebe7 : bd6f02          >            lda absEOa,x    ;precharge accu
ebea : 28              >            plp
                        
ebeb : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
ebee : 08              >            php         ;save flags
ebef : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ebf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ebf4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ebf5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ebf7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ebfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ebfc : ca                       dex
ebfd : 10e0                     bpl teor5
                        
ebff : a203                     ldx #3      ;zp,x
ec01 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
ec01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ec03 : 48              >            pha         ;use stack to load status
ec04 : bd6f02          >            lda absEOa,x    ;precharge accu
ec07 : 28              >            plp
                        
ec08 : 5568                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
ec0a : 08              >            php         ;save flags
ec0b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ec0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ec10 : 68              >            pla         ;load status
                       >            eor_flag 0
ec11 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ec13 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ec16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ec18 : ca                       dex
ec19 : 10e6                     bpl teor6
ec1b : a203                     ldx #3
ec1d :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ec1d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ec1f : 48              >            pha         ;use stack to load status
ec20 : bd6f02          >            lda absEOa,x    ;precharge accu
ec23 : 28              >            plp
                        
ec24 : 5568                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ec26 : 08              >            php         ;save flags
ec27 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ec2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ec2c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ec2d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ec2f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ec32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ec34 : ca                       dex
ec35 : 10e6                     bpl teor7
                        
ec37 : a203                     ldx #3      ;abs,x
ec39 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
ec39 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ec3b : 48              >            pha         ;use stack to load status
ec3c : bd6f02          >            lda absEOa,x    ;precharge accu
ec3f : 28              >            plp
                        
ec40 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
ec43 : 08              >            php         ;save flags
ec44 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ec47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ec49 : 68              >            pla         ;load status
                       >            eor_flag 0
ec4a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ec4c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ec4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ec51 : ca                       dex
ec52 : 10e5                     bpl teor8
ec54 : a203                     ldx #3
ec56 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
ec56 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ec58 : 48              >            pha         ;use stack to load status
ec59 : bd6f02          >            lda absEOa,x    ;precharge accu
ec5c : 28              >            plp
                        
ec5d : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
ec60 : 08              >            php         ;save flags
ec61 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ec64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ec66 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ec67 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ec69 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ec6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ec6e : ca                       dex
ec6f : 10e5                     bpl teor9
                        
ec71 : a003                     ldy #3      ;abs,y
ec73 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
ec73 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ec75 : 48              >            pha         ;use stack to load status
ec76 : b96f02          >            lda absEOa,y    ;precharge accu
ec79 : 28              >            plp
                        
ec7a : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
ec7d : 08              >            php         ;save flags
ec7e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ec81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ec83 : 68              >            pla         ;load status
                       >            eor_flag 0
ec84 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ec86 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ec89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ec8b : 88                       dey
ec8c : 10e5                     bpl teor10
ec8e : a003                     ldy #3
ec90 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ec90 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ec92 : 48              >            pha         ;use stack to load status
ec93 : b96f02          >            lda absEOa,y    ;precharge accu
ec96 : 28              >            plp
                        
ec97 : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
ec9a : 08              >            php         ;save flags
ec9b : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ec9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eca0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eca1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eca3 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eca6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eca8 : 88                       dey
eca9 : 10e5                     bpl teor11
                        
ecab : a206                     ldx #6      ;(zp,x)
ecad : a003                     ldy #3
ecaf :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
ecaf : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ecb1 : 48              >            pha         ;use stack to load status
ecb2 : b96f02          >            lda absEOa,y    ;precharge accu
ecb5 : 28              >            plp
                        
ecb6 : 418a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
ecb8 : 08              >            php         ;save flags
ecb9 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ecbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ecbe : 68              >            pla         ;load status
                       >            eor_flag 0
ecbf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ecc1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ecc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ecc6 : ca                       dex
ecc7 : ca                       dex
ecc8 : 88                       dey
ecc9 : 10e4                     bpl teor12
eccb : a206                     ldx #6
eccd : a003                     ldy #3
eccf :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
eccf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ecd1 : 48              >            pha         ;use stack to load status
ecd2 : b96f02          >            lda absEOa,y    ;precharge accu
ecd5 : 28              >            plp
                        
ecd6 : 418a                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
ecd8 : 08              >            php         ;save flags
ecd9 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ecdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ecde : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ecdf : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ece1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ece4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ece6 : ca                       dex
ece7 : ca                       dex
ece8 : 88                       dey
ece9 : 10e4                     bpl teor13
                        
eceb : a003                     ldy #3      ;(zp),y
eced :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
eced : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ecef : 48              >            pha         ;use stack to load status
ecf0 : b96f02          >            lda absEOa,y    ;precharge accu
ecf3 : 28              >            plp
                        
ecf4 : 518a                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
ecf6 : 08              >            php         ;save flags
ecf7 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ecfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ecfc : 68              >            pla         ;load status
                       >            eor_flag 0
ecfd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ecff : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ed02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ed04 : 88                       dey
ed05 : 10e6                     bpl teor14
ed07 : a003                     ldy #3
ed09 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
ed09 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ed0b : 48              >            pha         ;use stack to load status
ed0c : b96f02          >            lda absEOa,y    ;precharge accu
ed0f : 28              >            plp
                        
ed10 : 518a                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
ed12 : 08              >            php         ;save flags
ed13 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ed16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ed18 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ed19 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ed1b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ed1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ed20 : 88                       dey
ed21 : 10e6                     bpl teor15
                                next_test
ed23 : ad0002          >            lda test_case   ;previous test
ed26 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ed28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
ed2a : a928            >            lda #test_num   ;*** next tests' number
ed2c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
ed2f : a203                     ldx #3          ;immediate - self modifying code
ed31 : b560             tora    lda zpOR,x
ed33 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
ed36 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ed38 : 48              >            pha         ;use stack to load status
ed39 : bd6702          >            lda absORa,x    ;precharge accu
ed3c : 28              >            plp
                        
ed3d : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
ed40 : 08              >            php         ;save flags
ed41 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ed44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ed46 : 68              >            pla         ;load status
                       >            eor_flag 0
ed47 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ed49 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ed4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ed4e : ca                       dex
ed4f : 10e0                     bpl tora
ed51 : a203                     ldx #3
ed53 : b560             tora1   lda zpOR,x
ed55 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
ed58 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ed5a : 48              >            pha         ;use stack to load status
ed5b : bd6702          >            lda absORa,x    ;precharge accu
ed5e : 28              >            plp
                        
ed5f : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
ed62 : 08              >            php         ;save flags
ed63 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ed66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ed68 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ed69 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ed6b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ed6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ed70 : ca                       dex
ed71 : 10e0                     bpl tora1
                        
ed73 : a203                     ldx #3      ;zp
ed75 : b560             tora2   lda zpOR,x
ed77 : 8552                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
ed79 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ed7b : 48              >            pha         ;use stack to load status
ed7c : bd6702          >            lda absORa,x    ;precharge accu
ed7f : 28              >            plp
                        
ed80 : 0552                     ora zpt
                                tst_ax  absrlo,absflo,0
ed82 : 08              >            php         ;save flags
ed83 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ed86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ed88 : 68              >            pla         ;load status
                       >            eor_flag 0
ed89 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ed8b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ed8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ed90 : ca                       dex
ed91 : 10e2                     bpl tora2
ed93 : a203                     ldx #3
ed95 : b560             tora3   lda zpOR,x
ed97 : 8552                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
ed99 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ed9b : 48              >            pha         ;use stack to load status
ed9c : bd6702          >            lda absORa,x    ;precharge accu
ed9f : 28              >            plp
                        
eda0 : 0552                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
eda2 : 08              >            php         ;save flags
eda3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
eda6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eda8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eda9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
edab : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
edae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
edb0 : ca                       dex
edb1 : 10e2                     bpl tora3
                        
edb3 : a203                     ldx #3      ;abs
edb5 : b560             tora4   lda zpOR,x
edb7 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
edba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
edbc : 48              >            pha         ;use stack to load status
edbd : bd6702          >            lda absORa,x    ;precharge accu
edc0 : 28              >            plp
                        
edc1 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
edc4 : 08              >            php         ;save flags
edc5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
edc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
edca : 68              >            pla         ;load status
                       >            eor_flag 0
edcb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
edcd : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
edd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
edd2 : ca                       dex
edd3 : 10e0                     bpl tora4
edd5 : a203                     ldx #3
edd7 : b560             tora5   lda zpOR,x
edd9 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
eddc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
edde : 48              >            pha         ;use stack to load status
eddf : bd6702          >            lda absORa,x    ;precharge accu
ede2 : 28              >            plp
                        
ede3 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
ede6 : 08              >            php         ;save flags
ede7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
edea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
edec : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eded : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
edef : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
edf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
edf4 : ca                       dex
edf5 : 1002                     bpl tora6
                        
edf7 : a203                     ldx #3      ;zp,x
edf9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
edf9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
edfb : 48              >            pha         ;use stack to load status
edfc : bd6702          >            lda absORa,x    ;precharge accu
edff : 28              >            plp
                        
ee00 : 1560                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
ee02 : 08              >            php         ;save flags
ee03 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ee06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee08 : 68              >            pla         ;load status
                       >            eor_flag 0
ee09 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ee0b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ee0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ee10 : ca                       dex
ee11 : 10e6                     bpl tora6
ee13 : a203                     ldx #3
ee15 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
ee15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ee17 : 48              >            pha         ;use stack to load status
ee18 : bd6702          >            lda absORa,x    ;precharge accu
ee1b : 28              >            plp
                        
ee1c : 1560                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
ee1e : 08              >            php         ;save flags
ee1f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ee22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee24 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ee25 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ee27 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ee2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ee2c : ca                       dex
ee2d : 10e6                     bpl tora7
                        
ee2f : a203                     ldx #3      ;abs,x
ee31 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
ee31 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ee33 : 48              >            pha         ;use stack to load status
ee34 : bd6702          >            lda absORa,x    ;precharge accu
ee37 : 28              >            plp
                        
ee38 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
ee3b : 08              >            php         ;save flags
ee3c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ee3f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee41 : 68              >            pla         ;load status
                       >            eor_flag 0
ee42 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ee44 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ee47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ee49 : ca                       dex
ee4a : 10e5                     bpl tora8
ee4c : a203                     ldx #3
ee4e :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
ee4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ee50 : 48              >            pha         ;use stack to load status
ee51 : bd6702          >            lda absORa,x    ;precharge accu
ee54 : 28              >            plp
                        
ee55 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
ee58 : 08              >            php         ;save flags
ee59 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
ee5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee5e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ee5f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ee61 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
ee64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ee66 : ca                       dex
ee67 : 10e5                     bpl tora9
                        
ee69 : a003                     ldy #3      ;abs,y
ee6b :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
ee6b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
ee6d : 48              >            pha         ;use stack to load status
ee6e : b96702          >            lda absORa,y    ;precharge accu
ee71 : 28              >            plp
                        
ee72 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
ee75 : 08              >            php         ;save flags
ee76 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ee79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee7b : 68              >            pla         ;load status
                       >            eor_flag 0
ee7c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
ee7e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ee81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ee83 : 88                       dey
ee84 : 10e5                     bpl tora10
ee86 : a003                     ldy #3
ee88 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
ee88 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ee8a : 48              >            pha         ;use stack to load status
ee8b : b96702          >            lda absORa,y    ;precharge accu
ee8e : 28              >            plp
                        
ee8f : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
ee92 : 08              >            php         ;save flags
ee93 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ee96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ee98 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ee99 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ee9b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ee9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eea0 : 88                       dey
eea1 : 10e5                     bpl tora11
                        
eea3 : a206                     ldx #6      ;(zp,x)
eea5 : a003                     ldy #3
eea7 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
eea7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eea9 : 48              >            pha         ;use stack to load status
eeaa : b96702          >            lda absORa,y    ;precharge accu
eead : 28              >            plp
                        
eeae : 0192                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
eeb0 : 08              >            php         ;save flags
eeb1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eeb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eeb6 : 68              >            pla         ;load status
                       >            eor_flag 0
eeb7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eeb9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eebc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eebe : ca                       dex
eebf : ca                       dex
eec0 : 88                       dey
eec1 : 10e4                     bpl tora12
eec3 : a206                     ldx #6
eec5 : a003                     ldy #3
eec7 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
eec7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
eec9 : 48              >            pha         ;use stack to load status
eeca : b96702          >            lda absORa,y    ;precharge accu
eecd : 28              >            plp
                        
eece : 0192                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
eed0 : 08              >            php         ;save flags
eed1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eed4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eed6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
eed7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
eed9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eedc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eede : ca                       dex
eedf : ca                       dex
eee0 : 88                       dey
eee1 : 10e4                     bpl tora13
                        
eee3 : a003                     ldy #3      ;(zp),y
eee5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
eee5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
eee7 : 48              >            pha         ;use stack to load status
eee8 : b96702          >            lda absORa,y    ;precharge accu
eeeb : 28              >            plp
                        
eeec : 1192                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
eeee : 08              >            php         ;save flags
eeef : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
eef2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
eef4 : 68              >            pla         ;load status
                       >            eor_flag 0
eef5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
eef7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
eefa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
eefc : 88                       dey
eefd : 10e6                     bpl tora14
eeff : a003                     ldy #3
ef01 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
ef01 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
ef03 : 48              >            pha         ;use stack to load status
ef04 : b96702          >            lda absORa,y    ;precharge accu
ef07 : 28              >            plp
                        
ef08 : 1192                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
ef0a : 08              >            php         ;save flags
ef0b : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
ef0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
ef10 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
ef11 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
ef13 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
ef16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
ef18 : 88                       dey
ef19 : 10e6                     bpl tora15
                            if I_flag = 3
ef1b : 58                       cli
                            endif
                                next_test
ef1c : ad0002          >            lda test_case   ;previous test
ef1f : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ef21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
ef23 : a929            >            lda #test_num   ;*** next tests' number
ef25 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
ef28 : d8                       cld
ef29 : a254                     ldx #ad2        ;for indexed test
ef2b : a0ff                     ldy #$ff        ;max range
ef2d : a900                     lda #0          ;start with adding zeroes & no carry
ef2f : 8552                     sta adfc        ;carry in - for diag
ef31 : 8553                     sta ad1         ;operand 1 - accumulator
ef33 : 8554                     sta ad2         ;operand 2 - memory or immediate
ef35 : 8d0302                   sta ada2        ;non zp
ef38 : 8555                     sta adrl        ;expected result bits 0-7
ef3a : 8556                     sta adrh        ;expected result bit 8 (carry out)
ef3c : a9ff                     lda #$ff        ;complemented operand 2 for subtract
ef3e : 8558                     sta sb2
ef40 : 8d0402                   sta sba2        ;non zp
ef43 : a902                     lda #2          ;expected Z-flag
ef45 : 8557                     sta adrf
ef47 : 18               tadd    clc             ;test with carry clear
ef48 : 20c2f1                   jsr chkadd
ef4b : e652                     inc adfc        ;now with carry
ef4d : e655                     inc adrl        ;result +1
ef4f : 08                       php             ;save N & Z from low result
ef50 : 08                       php
ef51 : 68                       pla             ;accu holds expected flags
ef52 : 2982                     and #$82        ;mask N & Z
ef54 : 28                       plp
ef55 : d002                     bne tadd1
ef57 : e656                     inc adrh        ;result bit 8 - carry
ef59 : 0556             tadd1   ora adrh        ;merge C to expected flags
ef5b : 8557                     sta adrf        ;save expected flags except overflow
ef5d : 38                       sec             ;test with carry set
ef5e : 20c2f1                   jsr chkadd
ef61 : c652                     dec adfc        ;same for operand +1 but no carry
ef63 : e653                     inc ad1
ef65 : d0e0                     bne tadd        ;iterate op1
ef67 : a900                     lda #0          ;preset result to op2 when op1 = 0
ef69 : 8556                     sta adrh
ef6b : ee0302                   inc ada2
ef6e : e654                     inc ad2
ef70 : 08                       php             ;save NZ as operand 2 becomes the new result
ef71 : 68                       pla
ef72 : 2982                     and #$82        ;mask N00000Z0
ef74 : 8557                     sta adrf        ;no need to check carry as we are adding to 0
ef76 : c658                     dec sb2         ;complement subtract operand 2
ef78 : ce0402                   dec sba2
ef7b : a554                     lda ad2
ef7d : 8555                     sta adrl
ef7f : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
ef81 : ad0002          >            lda test_case   ;previous test
ef84 : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
ef86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
ef88 : a92a            >            lda #test_num   ;*** next tests' number
ef8a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
ef8d : f8                       sed
ef8e : a254                     ldx #ad2        ;for indexed test
ef90 : a0ff                     ldy #$ff        ;max range
ef92 : a999                     lda #$99        ;start with adding 99 to 99 with carry
ef94 : 8553                     sta ad1         ;operand 1 - accumulator
ef96 : 8554                     sta ad2         ;operand 2 - memory or immediate
ef98 : 8d0302                   sta ada2        ;non zp
ef9b : 8555                     sta adrl        ;expected result bits 0-7
ef9d : a901                     lda #1          ;set carry in & out
ef9f : 8552                     sta adfc        ;carry in - for diag
efa1 : 8556                     sta adrh        ;expected result bit 8 (carry out)
efa3 : a900                     lda #0          ;complemented operand 2 for subtract
efa5 : 8558                     sta sb2
efa7 : 8d0402                   sta sba2        ;non zp
efaa : 38               tdad    sec             ;test with carry set
efab : 208ff0                   jsr chkdad
efae : c652                     dec adfc        ;now with carry clear
efb0 : a555                     lda adrl        ;decimal adjust result
efb2 : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
efb4 : c656                     dec adrh
efb6 : a999                     lda #$99
efb8 : 8555                     sta adrl
efba : d012                     bne tdad3
efbc : 290f             tdad1   and #$f         ;lower nibble mask
efbe : d00c                     bne tdad2       ;no decimal adjust needed
efc0 : c655                     dec adrl        ;decimal adjust (?0-6)
efc2 : c655                     dec adrl
efc4 : c655                     dec adrl
efc6 : c655                     dec adrl
efc8 : c655                     dec adrl
efca : c655                     dec adrl
efcc : c655             tdad2   dec adrl        ;result -1
efce : 18               tdad3   clc             ;test with carry clear
efcf : 208ff0                   jsr chkdad
efd2 : e652                     inc adfc        ;same for operand -1 but with carry
efd4 : a553                     lda ad1         ;decimal adjust operand 1
efd6 : f015                     beq tdad5       ;iterate operand 2
efd8 : 290f                     and #$f         ;lower nibble mask
efda : d00c                     bne tdad4       ;skip decimal adjust
efdc : c653                     dec ad1         ;decimal adjust (?0-6)
efde : c653                     dec ad1
efe0 : c653                     dec ad1
efe2 : c653                     dec ad1
efe4 : c653                     dec ad1
efe6 : c653                     dec ad1
efe8 : c653             tdad4   dec ad1         ;operand 1 -1
efea : 4caaef                   jmp tdad        ;iterate op1
                        
efed : a999             tdad5   lda #$99        ;precharge op1 max
efef : 8553                     sta ad1
eff1 : a554                     lda ad2         ;decimal adjust operand 2
eff3 : f030                     beq tdad7       ;end of iteration
eff5 : 290f                     and #$f         ;lower nibble mask
eff7 : d018                     bne tdad6       ;skip decimal adjust
eff9 : c654                     dec ad2         ;decimal adjust (?0-6)
effb : c654                     dec ad2
effd : c654                     dec ad2
efff : c654                     dec ad2
f001 : c654                     dec ad2
f003 : c654                     dec ad2
f005 : e658                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
f007 : e658                     inc sb2
f009 : e658                     inc sb2
f00b : e658                     inc sb2
f00d : e658                     inc sb2
f00f : e658                     inc sb2
f011 : c654             tdad6   dec ad2         ;operand 2 -1
f013 : e658                     inc sb2         ;complemented operand for subtract
f015 : a558                     lda sb2
f017 : 8d0402                   sta sba2        ;copy as non zp operand
f01a : a554                     lda ad2
f01c : 8d0302                   sta ada2        ;copy as non zp operand
f01f : 8555                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
f021 : e656                     inc adrh        ;result carry
f023 : d085                     bne tdad        ;iterate op2
f025 :                  tdad7
                                next_test
f025 : ad0002          >            lda test_case   ;previous test
f028 : c92a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
f02a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002b =                 >test_num = test_num + 1
f02c : a92b            >            lda #test_num   ;*** next tests' number
f02e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
f031 : 18                       clc
f032 : d8                       cld
f033 : 08                       php
f034 : a955                     lda #$55
f036 : 6955                     adc #$55
f038 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after cld
f03a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f03c : 18                       clc
f03d : f8                       sed
f03e : 08                       php
f03f : a955                     lda #$55
f041 : 6955                     adc #$55
f043 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after sed
f045 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f047 : d8                       cld
f048 : 28                       plp
f049 : a955                     lda #$55
f04b : 6955                     adc #$55
f04d : c910                     cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
f04f : d0fe            >        bne *           ;failed not equal (non zero)
                        
f051 : 28                       plp
f052 : a955                     lda #$55
f054 : 6955                     adc #$55
f056 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
f058 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f05a : 18                       clc
f05b : a9f0                     lda #hi bin_rti_ret ;emulated interrupt for rti
f05d : 48                       pha
f05e : a975                     lda #lo bin_rti_ret
f060 : 48                       pha
f061 : 08                       php
f062 : f8                       sed
f063 : a9f0                     lda #hi dec_rti_ret ;emulated interrupt for rti
f065 : 48                       pha
f066 : a96c                     lda #lo dec_rti_ret
f068 : 48                       pha
f069 : 08                       php
f06a : d8                       cld
f06b : 40                       rti
f06c :                  dec_rti_ret
f06c : a955                     lda #$55
f06e : 6955                     adc #$55
f070 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
f072 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f074 : 40                       rti
f075 :                  bin_rti_ret
f075 : a955                     lda #$55
f077 : 6955                     adc #$55
f079 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
f07b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            endif
                        
f07d : ad0002                   lda test_case
f080 : c92b                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
f082 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f084 : a9f0                     lda #$f0        ;mark opcode testing complete
f086 : 8d0002                   sta test_case
                        
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------
                                success         ;if you get here everything went well
f089 : 4c89f0          >        jmp *           ;test passed, no errors
                        
                        ; -------------
                        ; S U C C E S S ************************************************
f08c : 4c00c0                   jmp start       ;run again
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
f08f :                  chkdad
                        ; decimal ADC / SBC zp
f08f : 08                       php             ;save carry for subtract
f090 : a553                     lda ad1
f092 : 6554                     adc ad2         ;perform add
f094 : 08                       php
f095 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f097 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f099 : 68                       pla             ;check flags
f09a : 2901                     and #1          ;mask carry
f09c : c556                     cmp adrh
                                trap_ne         ;bad carry
f09e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0a0 : 28                       plp
f0a1 : 08                       php             ;save carry for next add
f0a2 : a553                     lda ad1
f0a4 : e558                     sbc sb2         ;perform subtract
f0a6 : 08                       php
f0a7 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f0a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0ab : 68                       pla             ;check flags
f0ac : 2901                     and #1          ;mask carry
f0ae : c556                     cmp adrh
                                trap_ne         ;bad flags
f0b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0b2 : 28                       plp
                        ; decimal ADC / SBC abs
f0b3 : 08                       php             ;save carry for subtract
f0b4 : a553                     lda ad1
f0b6 : 6d0302                   adc ada2        ;perform add
f0b9 : 08                       php
f0ba : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f0bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0be : 68                       pla             ;check flags
f0bf : 2901                     and #1          ;mask carry
f0c1 : c556                     cmp adrh
                                trap_ne         ;bad carry
f0c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0c5 : 28                       plp
f0c6 : 08                       php             ;save carry for next add
f0c7 : a553                     lda ad1
f0c9 : ed0402                   sbc sba2        ;perform subtract
f0cc : 08                       php
f0cd : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f0cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0d1 : 68                       pla             ;check flags
f0d2 : 2901                     and #1          ;mask carry
f0d4 : c556                     cmp adrh
                                trap_ne         ;bad carry
f0d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0d8 : 28                       plp
                        ; decimal ADC / SBC #
f0d9 : 08                       php             ;save carry for subtract
f0da : a554                     lda ad2
f0dc : 8d1302                   sta ex_adci+1   ;set ADC # operand
f0df : a553                     lda ad1
f0e1 : 201202                   jsr ex_adci     ;execute ADC # in RAM
f0e4 : 08                       php
f0e5 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f0e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0e9 : 68                       pla             ;check flags
f0ea : 2901                     and #1          ;mask carry
f0ec : c556                     cmp adrh
                                trap_ne         ;bad carry
f0ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
f0f0 : 28                       plp
f0f1 : 08                       php             ;save carry for next add
f0f2 : a558                     lda sb2
f0f4 : 8d1602                   sta ex_sbci+1   ;set SBC # operand
f0f7 : a553                     lda ad1
f0f9 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
f0fc : 08                       php
f0fd : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f0ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
f101 : 68                       pla             ;check flags
f102 : 2901                     and #1          ;mask carry
f104 : c556                     cmp adrh
                                trap_ne         ;bad carry
f106 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f108 : 28                       plp
                        ; decimal ADC / SBC zp,x
f109 : 08                       php             ;save carry for subtract
f10a : a553                     lda ad1
f10c : 7500                     adc 0,x         ;perform add
f10e : 08                       php
f10f : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f111 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f113 : 68                       pla             ;check flags
f114 : 2901                     and #1          ;mask carry
f116 : c556                     cmp adrh
                                trap_ne         ;bad carry
f118 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f11a : 28                       plp
f11b : 08                       php             ;save carry for next add
f11c : a553                     lda ad1
f11e : f504                     sbc sb2-ad2,x   ;perform subtract
f120 : 08                       php
f121 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f123 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f125 : 68                       pla             ;check flags
f126 : 2901                     and #1          ;mask carry
f128 : c556                     cmp adrh
                                trap_ne         ;bad carry
f12a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f12c : 28                       plp
                        ; decimal ADC / SBC abs,x
f12d : 08                       php             ;save carry for subtract
f12e : a553                     lda ad1
f130 : 7daf01                   adc ada2-ad2,x  ;perform add
f133 : 08                       php
f134 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f136 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f138 : 68                       pla             ;check flags
f139 : 2901                     and #1          ;mask carry
f13b : c556                     cmp adrh
                                trap_ne         ;bad carry
f13d : d0fe            >        bne *           ;failed not equal (non zero)
                        
f13f : 28                       plp
f140 : 08                       php             ;save carry for next add
f141 : a553                     lda ad1
f143 : fdb001                   sbc sba2-ad2,x  ;perform subtract
f146 : 08                       php
f147 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f149 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f14b : 68                       pla             ;check flags
f14c : 2901                     and #1          ;mask carry
f14e : c556                     cmp adrh
                                trap_ne         ;bad carry
f150 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f152 : 28                       plp
                        ; decimal ADC / SBC abs,y
f153 : 08                       php             ;save carry for subtract
f154 : a553                     lda ad1
f156 : 790401                   adc ada2-$ff,y  ;perform add
f159 : 08                       php
f15a : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f15c : d0fe            >        bne *           ;failed not equal (non zero)
                        
f15e : 68                       pla             ;check flags
f15f : 2901                     and #1          ;mask carry
f161 : c556                     cmp adrh
                                trap_ne         ;bad carry
f163 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f165 : 28                       plp
f166 : 08                       php             ;save carry for next add
f167 : a553                     lda ad1
f169 : f90501                   sbc sba2-$ff,y  ;perform subtract
f16c : 08                       php
f16d : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f16f : d0fe            >        bne *           ;failed not equal (non zero)
                        
f171 : 68                       pla             ;check flags
f172 : 2901                     and #1          ;mask carry
f174 : c556                     cmp adrh
                                trap_ne         ;bad carry
f176 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f178 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
f179 : 08                       php             ;save carry for subtract
f17a : a553                     lda ad1
f17c : 6146                     adc (lo adi2-ad2,x) ;perform add
f17e : 08                       php
f17f : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f181 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f183 : 68                       pla             ;check flags
f184 : 2901                     and #1          ;mask carry
f186 : c556                     cmp adrh
                                trap_ne         ;bad carry
f188 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f18a : 28                       plp
f18b : 08                       php             ;save carry for next add
f18c : a553                     lda ad1
f18e : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
f190 : 08                       php
f191 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f193 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f195 : 68                       pla             ;check flags
f196 : 2901                     and #1          ;mask carry
f198 : c556                     cmp adrh
                                trap_ne         ;bad carry
f19a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f19c : 28                       plp
                        ; decimal ADC / SBC (abs),y
f19d : 08                       php             ;save carry for subtract
f19e : a553                     lda ad1
f1a0 : 719e                     adc (adiy2),y   ;perform add
f1a2 : 08                       php
f1a3 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f1a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1a7 : 68                       pla             ;check flags
f1a8 : 2901                     and #1          ;mask carry
f1aa : c556                     cmp adrh
                                trap_ne         ;bad carry
f1ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1ae : 28                       plp
f1af : 08                       php             ;save carry for next add
f1b0 : a553                     lda ad1
f1b2 : f1a0                     sbc (sbiy2),y   ;perform subtract
f1b4 : 08                       php
f1b5 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f1b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1b9 : 68                       pla             ;check flags
f1ba : 2901                     and #1          ;mask carry
f1bc : c556                     cmp adrh
                                trap_ne         ;bad carry
f1be : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1c0 : 28                       plp
f1c1 : 60                       rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
f1c2 : a557             chkadd  lda adrf        ;add V-flag if overflow
f1c4 : 2983                     and #$83        ;keep N-----ZC / clear V
f1c6 : 48                       pha
f1c7 : a553                     lda ad1         ;test sign unequal between operands
f1c9 : 4554                     eor ad2
f1cb : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
f1cd : a553                     lda ad1         ;test sign equal between operands and result
f1cf : 4555                     eor adrl
f1d1 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
f1d3 : 68                       pla
f1d4 : 0940                     ora #$40        ;set V
f1d6 : 48                       pha
f1d7 : 68               ckad1   pla
f1d8 : 8557                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
f1da : 08                       php             ;save carry for subtract
f1db : a553                     lda ad1
f1dd : 6554                     adc ad2         ;perform add
f1df : 08                       php
f1e0 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f1e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1e4 : 68                       pla             ;check flags
f1e5 : 29c3                     and #$c3        ;mask NV----ZC
f1e7 : c557                     cmp adrf
                                trap_ne         ;bad flags
f1e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1eb : 28                       plp
f1ec : 08                       php             ;save carry for next add
f1ed : a553                     lda ad1
f1ef : e558                     sbc sb2         ;perform subtract
f1f1 : 08                       php
f1f2 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f1f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1f6 : 68                       pla             ;check flags
f1f7 : 29c3                     and #$c3        ;mask NV----ZC
f1f9 : c557                     cmp adrf
                                trap_ne         ;bad flags
f1fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
f1fd : 28                       plp
                        ; binary ADC / SBC abs
f1fe : 08                       php             ;save carry for subtract
f1ff : a553                     lda ad1
f201 : 6d0302                   adc ada2        ;perform add
f204 : 08                       php
f205 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f207 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f209 : 68                       pla             ;check flags
f20a : 29c3                     and #$c3        ;mask NV----ZC
f20c : c557                     cmp adrf
                                trap_ne         ;bad flags
f20e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f210 : 28                       plp
f211 : 08                       php             ;save carry for next add
f212 : a553                     lda ad1
f214 : ed0402                   sbc sba2        ;perform subtract
f217 : 08                       php
f218 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f21a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f21c : 68                       pla             ;check flags
f21d : 29c3                     and #$c3        ;mask NV----ZC
f21f : c557                     cmp adrf
                                trap_ne         ;bad flags
f221 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f223 : 28                       plp
                        ; binary ADC / SBC #
f224 : 08                       php             ;save carry for subtract
f225 : a554                     lda ad2
f227 : 8d1302                   sta ex_adci+1   ;set ADC # operand
f22a : a553                     lda ad1
f22c : 201202                   jsr ex_adci     ;execute ADC # in RAM
f22f : 08                       php
f230 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f232 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f234 : 68                       pla             ;check flags
f235 : 29c3                     and #$c3        ;mask NV----ZC
f237 : c557                     cmp adrf
                                trap_ne         ;bad flags
f239 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f23b : 28                       plp
f23c : 08                       php             ;save carry for next add
f23d : a558                     lda sb2
f23f : 8d1602                   sta ex_sbci+1   ;set SBC # operand
f242 : a553                     lda ad1
f244 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
f247 : 08                       php
f248 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f24a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f24c : 68                       pla             ;check flags
f24d : 29c3                     and #$c3        ;mask NV----ZC
f24f : c557                     cmp adrf
                                trap_ne         ;bad flags
f251 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f253 : 28                       plp
                        ; binary ADC / SBC zp,x
f254 : 08                       php             ;save carry for subtract
f255 : a553                     lda ad1
f257 : 7500                     adc 0,x         ;perform add
f259 : 08                       php
f25a : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f25c : d0fe            >        bne *           ;failed not equal (non zero)
                        
f25e : 68                       pla             ;check flags
f25f : 29c3                     and #$c3        ;mask NV----ZC
f261 : c557                     cmp adrf
                                trap_ne         ;bad flags
f263 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f265 : 28                       plp
f266 : 08                       php             ;save carry for next add
f267 : a553                     lda ad1
f269 : f504                     sbc sb2-ad2,x   ;perform subtract
f26b : 08                       php
f26c : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f26e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f270 : 68                       pla             ;check flags
f271 : 29c3                     and #$c3        ;mask NV----ZC
f273 : c557                     cmp adrf
                                trap_ne         ;bad flags
f275 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f277 : 28                       plp
                        ; binary ADC / SBC abs,x
f278 : 08                       php             ;save carry for subtract
f279 : a553                     lda ad1
f27b : 7daf01                   adc ada2-ad2,x  ;perform add
f27e : 08                       php
f27f : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f281 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f283 : 68                       pla             ;check flags
f284 : 29c3                     and #$c3        ;mask NV----ZC
f286 : c557                     cmp adrf
                                trap_ne         ;bad flags
f288 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f28a : 28                       plp
f28b : 08                       php             ;save carry for next add
f28c : a553                     lda ad1
f28e : fdb001                   sbc sba2-ad2,x  ;perform subtract
f291 : 08                       php
f292 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f294 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f296 : 68                       pla             ;check flags
f297 : 29c3                     and #$c3        ;mask NV----ZC
f299 : c557                     cmp adrf
                                trap_ne         ;bad flags
f29b : d0fe            >        bne *           ;failed not equal (non zero)
                        
f29d : 28                       plp
                        ; binary ADC / SBC abs,y
f29e : 08                       php             ;save carry for subtract
f29f : a553                     lda ad1
f2a1 : 790401                   adc ada2-$ff,y  ;perform add
f2a4 : 08                       php
f2a5 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f2a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2a9 : 68                       pla             ;check flags
f2aa : 29c3                     and #$c3        ;mask NV----ZC
f2ac : c557                     cmp adrf
                                trap_ne         ;bad flags
f2ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2b0 : 28                       plp
f2b1 : 08                       php             ;save carry for next add
f2b2 : a553                     lda ad1
f2b4 : f90501                   sbc sba2-$ff,y  ;perform subtract
f2b7 : 08                       php
f2b8 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f2ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2bc : 68                       pla             ;check flags
f2bd : 29c3                     and #$c3        ;mask NV----ZC
f2bf : c557                     cmp adrf
                                trap_ne         ;bad flags
f2c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2c3 : 28                       plp
                        ; binary ADC / SBC (zp,x)
f2c4 : 08                       php             ;save carry for subtract
f2c5 : a553                     lda ad1
f2c7 : 6146                     adc (lo adi2-ad2,x) ;perform add
f2c9 : 08                       php
f2ca : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f2cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2ce : 68                       pla             ;check flags
f2cf : 29c3                     and #$c3        ;mask NV----ZC
f2d1 : c557                     cmp adrf
                                trap_ne         ;bad flags
f2d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2d5 : 28                       plp
f2d6 : 08                       php             ;save carry for next add
f2d7 : a553                     lda ad1
f2d9 : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
f2db : 08                       php
f2dc : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f2de : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2e0 : 68                       pla             ;check flags
f2e1 : 29c3                     and #$c3        ;mask NV----ZC
f2e3 : c557                     cmp adrf
                                trap_ne         ;bad flags
f2e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2e7 : 28                       plp
                        ; binary ADC / SBC (abs),y
f2e8 : 08                       php             ;save carry for subtract
f2e9 : a553                     lda ad1
f2eb : 719e                     adc (adiy2),y   ;perform add
f2ed : 08                       php
f2ee : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f2f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2f2 : 68                       pla             ;check flags
f2f3 : 29c3                     and #$c3        ;mask NV----ZC
f2f5 : c557                     cmp adrf
                                trap_ne         ;bad flags
f2f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f2f9 : 28                       plp
f2fa : 08                       php             ;save carry for next add
f2fb : a553                     lda ad1
f2fd : f1a0                     sbc (sbiy2),y   ;perform subtract
f2ff : 08                       php
f300 : c555                     cmp adrl        ;check result
                                trap_ne         ;bad result
f302 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f304 : 68                       pla             ;check flags
f305 : 29c3                     and #$c3        ;mask NV----ZC
f307 : c557                     cmp adrf
                                trap_ne         ;bad flags
f309 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f30b : 28                       plp
f30c : 60                       rts
                        
                        ; target for the jump absolute test
f30d : 88                       dey
f30e : 88                       dey
f30f :                  test_far
f30f : 08                       php             ;either SP or Y count will fail, if we do not hit
f310 : 88                       dey
f311 : 88                       dey
f312 : 88                       dey
f313 : 28                       plp
                                trap_cs         ;flags loaded?
f314 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
f316 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
f318 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
f31a : f0fe            >        beq *           ;failed equal (zero)
                        
f31c : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
f31e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f320 : e041                     cpx #'A'
                                trap_ne
f322 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f324 : c04f                     cpy #('R'-3)
                                trap_ne
f326 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f328 : 48                       pha             ;save a,x
f329 : 8a                       txa
f32a : 48                       pha
f32b : ba                       tsx
f32c : e0fd                     cpx #$fd        ;check SP
                                trap_ne
f32e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f330 : 68                       pla             ;restore x
f331 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
f332 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
f334 : 48              >            pha         ;use stack to load status
f335 : 28              >            plp
                        
f336 : 68                       pla             ;restore a
f337 : e8                       inx             ;return registers with modifications
f338 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
f33a : 4c2fc5                   jmp far_ret
                        
                        ; target for the jump indirect test
f33d : 00                       align
f33e : 47f3             ptr_tst_ind dw test_ind
f340 : 84c5             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
f342 : 4c42f3          >        jmp *           ;failed anyway
                        
f345 : 88                       dey
f346 : 88                       dey
f347 :                  test_ind
f347 : 08                       php             ;either SP or Y count will fail, if we do not hit
f348 : 88                       dey
f349 : 88                       dey
f34a : 88                       dey
f34b : 28                       plp
                                trap_cs         ;flags loaded?
f34c : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
f34e : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
f350 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
f352 : f0fe            >        beq *           ;failed equal (zero)
                        
f354 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
f356 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f358 : e04e                     cpx #'N'
                                trap_ne
f35a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f35c : c041                     cpy #('D'-3)
                                trap_ne
f35e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f360 : 48                       pha             ;save a,x
f361 : 8a                       txa
f362 : 48                       pha
f363 : ba                       tsx
f364 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
f366 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f368 : 68                       pla             ;restore x
f369 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
f36a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
f36c : 48              >            pha         ;use stack to load status
f36d : 28              >            plp
                        
f36e : 68                       pla             ;restore a
f36f : e8                       inx             ;return registers with modifications
f370 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
f372 : 6c40f3                   jmp (ptr_ind_ret)
                                trap            ;runover protection
f375 : 4c75f3          >        jmp *           ;failed anyway
                        
f378 : 4c00c0                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
f37b : 88                       dey
f37c : 88                       dey
f37d :                  test_jsr
f37d : 08                       php             ;either SP or Y count will fail, if we do not hit
f37e : 88                       dey
f37f : 88                       dey
f380 : 88                       dey
f381 : 28                       plp
                                trap_cs         ;flags loaded?
f382 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
f384 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
f386 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq
f388 : f0fe            >        beq *           ;failed equal (zero)
                        
f38a : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
f38c : d0fe            >        bne *           ;failed not equal (non zero)
                        
f38e : e053                     cpx #'S'
                                trap_ne
f390 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f392 : c04f                     cpy #('R'-3)
                                trap_ne
f394 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f396 : 48                       pha             ;save a,x
f397 : 8a                       txa
f398 : 48                       pha
f399 : ba                       tsx             ;sp -4? (return addr,a,x)
f39a : e0fb                     cpx #$fb
                                trap_ne
f39c : d0fe            >        bne *           ;failed not equal (non zero)
                        
f39e : adff01                   lda $1ff        ;propper return on stack
f3a1 : c9c5                     cmp #hi(jsr_ret)
                                trap_ne
f3a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3a5 : adfe01                   lda $1fe
f3a8 : c9ba                     cmp #lo(jsr_ret)
                                trap_ne
f3aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
f3ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
f3ae : 48              >            pha         ;use stack to load status
f3af : 28              >            plp
                        
f3b0 : 68                       pla             ;pull x,a
f3b1 : aa                       tax
f3b2 : 68                       pla
f3b3 : e8                       inx             ;return registers with modifications
f3b4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
f3b6 : 60                       rts
                                trap            ;runover protection
f3b7 : 4cb7f3          >        jmp *           ;failed anyway
                        
f3ba : 4c00c0                   jmp start       ;catastrophic error - cannot continue
                        
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
f3bd :                  nmi_trap
                                trap            ;check stack for conditions at NMI
f3bd : 4cbdf3          >        jmp *           ;failed anyway
                        
f3c0 : 4c00c0                   jmp start       ;catastrophic error - cannot continue
f3c3 :                  res_trap
                                trap            ;unexpected RESET
f3c3 : 4cc3f3          >        jmp *           ;failed anyway
                        
f3c6 : 4c00c0                   jmp start       ;catastrophic error - cannot continue
                        
f3c9 : 88                       dey
f3ca : 88                       dey
f3cb :                  irq_trap                ;BRK test or unextpected BRK or IRQ
f3cb : 08                       php             ;either SP or Y count will fail, if we do not hit
f3cc : 88                       dey
f3cd : 88                       dey
f3ce : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
f3cf : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
f3d1 : f042                     beq break2
f3d3 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
f3d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3d7 : e052                     cpx #'R'
                                trap_ne
f3d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3db : c048                     cpy #'K'-3
                                trap_ne
f3dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3df : 8550                     sta irq_a       ;save registers during break test
f3e1 : 8651                     stx irq_x
f3e3 : ba                       tsx             ;test break on stack
f3e4 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
f3e7 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
f3e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3eb : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
f3ec : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
f3ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3f0 : ba                       tsx
f3f1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
f3f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3f5 : adff01                   lda $1ff        ;propper return on stack
f3f8 : c9c5                     cmp #hi(brk_ret0)
                                trap_ne
f3fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
f3fc : adfe01                   lda $1fe
f3ff : c9f1                     cmp #lo(brk_ret0)
                                trap_ne
f401 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
f403 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
f405 : 48                       pha
f406 : a651                     ldx irq_x
f408 : e8                       inx             ;return registers with modifications
f409 : a550                     lda irq_a
f40b : 49aa                     eor #$aa
f40d : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
f40e : 40                       rti
                                trap            ;runover protection
f40f : 4c0ff4          >        jmp *           ;failed anyway
                        
f412 : 4c00c0                   jmp start       ;catastrophic error - cannot continue
                        
f415 :                  break2                  ;BRK pass 2
f415 : e0ad                     cpx #$ff-'R'
                                trap_ne
f417 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f419 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
f41b : d0fe            >        bne *           ;failed not equal (non zero)
                        
f41d : 8550                     sta irq_a       ;save registers during break test
f41f : 8651                     stx irq_x
f421 : ba                       tsx             ;test break on stack
f422 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
f425 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
f427 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f429 : 68                       pla
f42a : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
f42c : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
f42e : d0fe            >        bne *           ;failed not equal (non zero)
                        
f430 : ba                       tsx
f431 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
f433 : d0fe            >        bne *           ;failed not equal (non zero)
                        
f435 : adff01                   lda $1ff        ;propper return on stack
f438 : c9c6                     cmp #hi(brk_ret1)
                                trap_ne
f43a : d0fe            >        bne *           ;failed not equal (non zero)
                        
f43c : adfe01                   lda $1fe
f43f : c917                     cmp #lo(brk_ret1)
                                trap_ne
f441 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
f443 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
f445 : 48                       pha
f446 : a651                     ldx irq_x
f448 : e8                       inx             ;return registers with modifications
f449 : a550                     lda irq_a
f44b : 49aa                     eor #$aa
f44d : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
f44e : 40                       rti
                                trap            ;runover protection
f44f : 4c4ff4          >        jmp *           ;failed anyway
                        
f452 : 4c00c0                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                        
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
f455 :                  zp_init
f455 : 8001             zps_    db  $80,1           ;additional shift pattern to test zero result & flag
f457 : c3824100         zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
f45b : 7f               zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
f45c : 001f7180         zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
f460 : 0fff7f80         zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
f464 : ff0f8f8f         zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
f468 : 1802             ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
f46a : 1902                     dw  abs1+1
f46c : 1a02                     dw  abs1+2
f46e : 1b02                     dw  abs1+3
f470 : 1c02                     dw  abs7f
f472 : 2001             inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
f474 : 0302             indt_   dw  abst            ;indirect pointer to store area in absolute memory
f476 : 0402                     dw  abst+1
f478 : 0502                     dw  abst+2
f47a : 0602                     dw  abst+3
f47c : 0b01             inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
f47e : 5f02             indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
f480 : 6002                     dw  absAN+1
f482 : 6102                     dw  absAN+2
f484 : 6202                     dw  absAN+3
f486 : 6302             indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
f488 : 6402                     dw  absEO+1
f48a : 6502                     dw  absEO+2
f48c : 6602                     dw  absEO+3
f48e : 5b02             indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
f490 : 5c02                     dw  absOR+1
f492 : 5d02                     dw  absOR+2
f494 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
f496 : 0302             adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
f498 : 0402             sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
f49a : 0401             adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
f49c : 0501             sbiy2_  dw  sba2-$ff
f49e :                  zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)
                                ;force assembler error if size is different
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif
f49e :                  data_init
f49e : 2900             ex_and_ and #0              ;execute immediate opcodes
f4a0 : 60                       rts
f4a1 : 4900             ex_eor_ eor #0              ;execute immediate opcodes
f4a3 : 60                       rts
f4a4 : 0900             ex_ora_ ora #0              ;execute immediate opcodes
f4a6 : 60                       rts
f4a7 : 6900             ex_adc_ adc #0              ;execute immediate opcodes
f4a9 : 60                       rts
f4aa : e900             ex_sbc_ sbc #0              ;execute immediate opcodes
f4ac : 60                       rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
f4ad : c3824100         abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
f4b1 : 7f               abs7f_  db  $7f             ;test pattern for compare
                        ;loads
f4b2 : 80800002         fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
f4b6 :                  rASL_                               ;expected result ASL & ROL -carry
f4b6 : 000286048200     rROL_   db  0,2,$86,$04,$82,0
f4bc : 010387058301     rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
f4c2 :                  rLSR_                               ;expected result LSR & ROR -carry
f4c2 : 400061412000     rROR_   db  $40,0,$61,$41,$20,0
f4c8 : c080e1c1a080     rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
f4ce :                  fASL_                               ;expected flags for shifts
f4ce : 030081018002     fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
f4d4 : 010081018000     fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in
f4da :                  fLSR_
f4da : 000301000102     fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
f4e0 : 808181808180     fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
f4e6 : 7f80ff0001       rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
f4eb : 0080800200       fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
f4f0 : 001f7180         absOR_  db  0,$1f,$71,$80           ;test pattern for OR
f4f4 : 0fff7f80         absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
f4f8 : ff0f8f8f         absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
f4fc : 00f11f00         absORa_ db  0,$f1,$1f,0             ;test pattern for OR
f500 : f0ffffff         absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
f504 : fff0f00f         absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
f508 : 00ff7f80         absrlo_ db  0,$ff,$7f,$80
f50c : 02800080         absflo_ db  fz,fn,0,fn
f510 :                  data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif
                        
f510 :                  vec_init
f510 : bdf3                     dw  nmi_trap
f512 : c3f3                     dw  res_trap
f514 : cbf3                     dw  irq_trap
fffa =                  vec_bss equ $fffa
                            endif                   ;end of RAM init data
                        
                        ;;    if (ROM_vectors = 1)
                        ;;        org $fffa       ;vectors
                        ;;        dw  nmi_trap
                        ;;        dw  res_trap
                        ;;        dw  irq_trap
                        ;;    endif
                        
                            if (ROM_vectors = 1)
fffa =                          org $fffa       ;vectors
fffa : bdf3                     dw  nmi_trap
fffc : 00c0                     dw  start
fffe : cbf3                     dw  irq_trap
                            endif
                        
fffa =                          end start
                        
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
Program start address is at $c000 (49152).
